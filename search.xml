<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[配置七牛云]]></title>
    <url>%2F2017%2F09%2F05%2F%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%2F</url>
    <content type="text"><![CDATA[laravel 配置七牛云 composer.json 或 composer require zgldh/qiniu-laravel-storage&gt; 1"zgldh/qiniu-laravel-storage": "^0.8.1" config/app.php 1zgldh\QiniuStorage\QiniuFilesystemServiceProvider::class, config/filesystems.php 123456789101112'qiniu' =&gt; [ 'driver' =&gt; 'qiniu', 'domains' =&gt; [ 'default' =&gt; 'ovmscef5i.bkt.clouddn.com', //你的七牛域名 'https' =&gt; '', //你的HTTPS域名 'custom' =&gt; '', //你的自定义域名 ], 'access_key'=&gt; 'lqXMMY6JYjGEM-x0WgoJ84i35fc3BW2sMtOZXyzM', //AccessKey 'secret_key'=&gt; 'zRMFaIJ44i2KQZrN32GxWpO0_1ceU1heUsMSuLlH', //SecretKey 'bucket' =&gt; 'quanzi', //Bucket名字 'notify_url'=&gt; '', //持久化处理回调地址 ], 语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455use zgldh\QiniuStorage\QiniuStorage;$disk = QiniuStorage::disk('qiniu');$disk-&gt;exists('file.jpg'); //文件是否存在$disk-&gt;get('file.jpg'); //获取文件内容$disk-&gt;put('file.jpg',$contents); //上传文件$disk-&gt;put('file.jpg',fopen('path/to/big.jpg','r+')); //分段上传文件。建议大文件&gt;10Mb使用。$disk-&gt;prepend('file.log', 'Prepended Text'); //附加内容到文件开头$disk-&gt;append('file.log', 'Appended Text'); //附加内容到文件结尾$disk-&gt;delete('file.jpg'); //删除文件$disk-&gt;delete(['file1.jpg', 'file2.jpg']);$disk-&gt;copy('old/file1.jpg', 'new/file1.jpg'); //复制文件到新的路径$disk-&gt;move('old/file1.jpg', 'new/file1.jpg'); //移动文件到新的路径$size = $disk-&gt;size('file1.jpg'); //取得文件大小$time = $disk-&gt;lastModified('file1.jpg'); //取得最近修改时间 (UNIX)$files = $disk-&gt;files($directory); //取得目录下所有文件$files = $disk-&gt;allFiles($directory); //这个没实现。。。$directories = $disk-&gt;directories($directory); //这个也没实现。。。$directories = $disk-&gt;allDirectories($directory); //这个也没实现。。。$disk-&gt;makeDirectory($directory); //这个其实没有任何作用$disk-&gt;deleteDirectory($directory); //删除目录，包括目录下所有子文件子目录$disk-&gt;uploadToken(); //获取上传Token$disk-&gt;uploadToken('file.jpg'); //获取上传Token $disk-&gt;withUploadToken($token); // 使用自定义的 uploadToken 进行上传，$disk-&gt;put('file.jpg',$content); // 则本次的 put 操作，将使用上述的 $token 进行上传。 // 常用于自动触发持久化处理 https://github.com/qiniu/php-sdk/blob/master/examples/upload_and_pfop.php $disk-&gt;downloadUrl('file.jpg'); //获取下载地址$disk-&gt;downloadUrl('file.jpg') -&gt;setDownload('foo.jpg'); //获取下载地址，文件名为 foo.jpg$disk-&gt;downloadUrl('file.jpg', 'https'); //获取HTTPS下载地址$disk-&gt;privateDownloadUrl('file.jpg'); //获取私有bucket下载地址$disk-&gt;privateDownloadUrl('file.jpg?attname=foo.jpg'); //获取私有bucket下载地址，文件名为 foo.jpg$disk-&gt;privateDownloadUrl('file.jpg', 'https'); //获取私有bucket的HTTPS下载地址$disk-&gt;privateDownloadUrl('file.jpg', [ 'domain'=&gt;'https', 'expires'=&gt;3600 ]); //获取私有bucket的HTTPS下载地址。超时 3600 秒。$disk-&gt;avInfo('file.mp3'); //获取多媒体文件信息$disk-&gt;imageInfo('file.jpg'); //获取图片信息$disk-&gt;imageExif('file.jpg'); //获取图片EXIF信息$disk-&gt;imagePreviewUrl('file.jpg','imageView2/0/w/100/h/200'); //获取图片预览URL$disk-&gt;privateImagePreviewUrl('file.jpg','imageView2/0/w/100/h/200'); //获取私有bucket图片预览URL$disk-&gt;verifyCallback('application/x-www-form-urlencoded', $request-&gt;header('Authorization'), 'callback url', $request-&gt;getContent());//验证回调内容是否合法$disk-&gt;persistentFop('file.flv','avthumb/m3u8/segtime/40/vcodec/libx264/s/320x240'); //执行持久化数据处理$disk-&gt;persistentFop('file.flv','fop','队列名'); //使用私有队列执行持久化数据处理$disk-&gt;persistentStatus($persistent_fop_id); //查看持久化数据处理的状态。$disk-&gt;fetch('http://abc.com/foo.jpg', 'bar.jpg'); //调用fetch将 foo.jpg 数据以 bar.jpg 的名字储存起来。$disk-&gt;qetag(); //得到最后一次执行 put, copy, append 等写入操作后，得到的hash值。详见 https://github.com/qiniu/qetag$disk-&gt;lastReturn();//得到最后一次执行 put, copy, append 等写入操作后，得到的返回值。]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>qiniuyun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口需要的参数]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%8E%A5%E5%8F%A3%E9%9C%80%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[项目中接口需要的参数 提交评论接口 1、被评论条目的 id（作为 parent_id）2、评论所属文章或其他的 id（用 attach 与所属文章建立关系）]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>params</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 用 async 控制并发]]></title>
    <url>%2F2017%2F08%2F19%2Fnodejs-%E7%94%A8-async-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[用 async 函数控制 Node.js 的并发 async.map 异步还是根据延时进行async.mapSeries 一个完了才执行下一个async.mapLimit 并行执行，第二个参数为最多n个函数并行，只有当其中一个或多个完成的时候才可以继续并行 1、顺序执行，延时的异步操作仍在按队列机制进行123456789101112131415161718192021222324var arr = [&#123;name: 'Jack', dalay:200&#125;, &#123;name: 'Mike', delay: 100&#125;, &#123;name: 'Freewind', delay:300&#125;, &#123;name: 'Test', dalay:50&#125;];async.map(arr, function(item, callback) &#123; log('1.1 enter: ' + item.name); setTimeout(function() &#123; log('1.1 handle: ' + item.name); // callback 为 async.map 的第三个参数，第一个参数为错误信息err, 第二个参数为按元素顺序汇总的结果 callback(null, item.name + '!!!'); &#125;, item.delay);&#125;, function(err, results) &#123; log('1.1 err: ', err); log('1.1 results: ', results);&#125;);// 54.569&gt; 1.1 enter: Jack// 54.569&gt; 1.1 enter: Mike// 54.569&gt; 1.1 enter: Freewind// 54.569&gt; 1.1 enter: Test// 54.629&gt; 1.1 handle: Test// 54.679&gt; 1.1 handle: Mike// 54.789&gt; 1.1 handle: Jack// 54.879&gt; 1.1 handle: Freewind// 54.879&gt; 1.1 err:// 54.879&gt; 1.1 results: [ 'Jack!!!', 'Mike!!!', 'Freewind!!!', 'Test!!!' 2、如果中途出错，立刻将错误，以及已经执行完成的结果汇总给最终callback，未执行完的将会在数组中占个空位1234567891011121314151617181920212223242526var arr = [&#123;name: 'Jack', dalay:200&#125;, &#123;name: 'Mike', delay: 100&#125;, &#123;name: 'Freewind', delay:300&#125;, &#123;name: 'Test', dalay:50&#125;];async.map(arr, function(item, callback) &#123; log('1.2 enter: ', item.name); setTimeout(function() &#123; lof('1.2 handle: ' + item.name); if(item.name === 'Jack') callback('myerr'); //传一个错误信息参数给最后的callback else callback(null, item.name + '!!!'); //传一个结果给最后callback，错误信息为null &#125;, item.delay);&#125;, function(err, result) &#123; log('1.2 err: ', err); log('1.2 results: ', results);&#125;);// 按延时顺序执行到错误才马上返回// 54.569&gt; 1.2 enter: Jack// 54.569&gt; 1.2 enter: Mike// 54.569&gt; 1.2 enter: Freewind// 54.569&gt; 1.2 enter: Test// 54.629&gt; 1.2 handle: Test// 54.679&gt; 1.2 handle: Mike// 54.789&gt; 1.2 handle: Jack// 54.789&gt; 1.2 err: myerr// 54.789&gt; 1.2 results: [ undefined, 'Mike!!!', , 'Test!!!' ]// 54.879&gt; 1.2 handle: Freewind 3、顺序执行，一个完了才到下一个1234567891011121314151617181920212223var arr = [&#123;name: 'Jack', dalay:200&#125;, &#123;name: 'Mike', delay: 100&#125;, &#123;name: 'Freewind', delay:300&#125;, &#123;name: 'Test', dalay:50&#125;];async.mapSeries(arr, function(item, callback) &#123; log('1.3 enter: ' + item.name); setTimeout(function() &#123; log('1.3 handle: ' + item.name); callback(null, item.name + '!!!'); &#125;, item.delay);&#125;, function(err, results) &#123; log('1.3 err: ', err); log('1.3 results: ', results);&#125;);// 54.569&gt; 1.3 enter: Jack// 54.789&gt; 1.3 handle: Jack// 54.789&gt; 1.3 enter: Mike// 54.899&gt; 1.3 handle: Mike// 54.899&gt; 1.3 enter: Freewind// 55.209&gt; 1.3 handle: Freewind// 55.209&gt; 1.3 enter: Test// 55.269&gt; 1.3 handle: Test// 55.269&gt; 1.3 err:// 55.269&gt; 1.3 results: [ 'Jack!!!', 'Mike!!!', 'Freewind!!!', 'Test!!!' ] 4、顺序执行出错，把错误已经执行完的传给最终callback，未执行的忽略12345678910111213141516171819var arr = [&#123;name: 'Jack', dalay:200&#125;, &#123;name: 'Mike', delay: 100&#125;, &#123;name: 'Freewind', delay:300&#125;, &#123;name: 'Test', dalay:50&#125;];async.mapSeries(arr, function(item, callback) &#123; log('1.4 enter: ' + item.name); setTimeout(function() &#123; log('1.4 handle: ' + item.name); callback(null, item.name + '!!!'); &#125;, item.delay);&#125;, function(err, results) &#123; log('1.4 err: ', err); log('1.4 results: ', results);&#125;);// 47.616&gt; 1.4 enter: Jack// 47.821&gt; 1.4 handle: Jack// 47.821&gt; 1.4 enter: Mike// 47.931&gt; 1.4 handle: Mike// 47.931&gt; 1.4 err: myerr// 47.932&gt; 1.4 results: [ 'Jack!!!', undefined ] 5、并行执行，控制并行数量12345678910111213141516171819202122async.mapLimit(arr, 2, function(item, callback)&#123; log('1.5 enter ' + item.name); setTimeout(function() &#123; log('1.5 handle: ' + item.name); if(item.name === 'Jack') callback('myerr'); else callback(null, item.name + '!!!'); &#125;, item.delay);&#125;, function(err, results) &#123; log('1.5 err: ', err); log('1.5 results: ', results);&#125;);//57.797&gt; 1.5 enter: Jack//57.800&gt; 1.5 enter: Mike//57.900&gt; 1.5 handle: Mike//57.900&gt; 1.5 enter: Freewind//58.008&gt; 1.5 handle: Jack//58.009&gt; 1.5 err: myerr//58.009&gt; 1.5 results: [ undefined, 'Mike!!!' ]//58.208&gt; 1.5 handle: Freewind//58.208&gt; 1.5 enter: Test//58.273&gt; 1.5 handle: Test]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 模块]]></title>
    <url>%2F2017%2F08%2F15%2FNodejs-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Nodejs模块 superagent 用来发起 get 或者 post 请求1$ npm install superagent --save http://visionmedia.github.io/superagent cheerio 用来获取html元素内容（配合superagent使用）1$ npm install cheerio --save https://github.com/cheeriojs/cheerio superagent 配合 cheerio 写爬虫 12345678910111213141516171819202122232425var express = require("express");var superagent = require("superagent");var cheerio = require("cheerio");var app = express();app.get('/', function(req, res, next) &#123; superagent.get('https://cnodejs.org/') .end(function(err, sres) &#123; if (err) &#123; return next(err); &#125; var $ = cheerio.load(sres.text); var items = []; $('#topic_list .topic_title').each(function (idx, element) &#123; var $element = $(element); items.push(&#123; title: $element.attr('title'), href: $element.attr('href') &#125;); &#125;); res.send(items); &#125;);&#125;);app.listen(3000); eventproxy 用来处理并发执行1$ npm install eventproxy 并发处理例子:ep.all 监听了三个事件，每当一个源的数据抓取完成时，就通过 ep.emit() 告诉 ep 自己，某某事件已经完成了。只有当三个事件都完成的时候，才会调用末尾的回调函数统一处理12345678910111213141516var eventproxy = require("eventproxy")var ep = new eventproxy();ep.all('data1_event', 'data2_event', 'data3_event', function(data1, data2, data3) &#123; var html = fuck(data1, data2, data3); render(html);&#125;);$.get('http://data1_source', function(data) &#123; ep.emit('data1_event', data);&#125;);$.get('http://data2_source', function(data) &#123; ep.emit('data2_event', data);&#125;);$.get('http://data3_source', function(data) &#123; ep.emit('data3_event', data);&#125;); 重复异步协作https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C 123456789101112131415161718192021222324252627282930313233343536// 得到 topicUrls 之后// 得到一个 eventproxy 的实例var ep = new eventproxy();// ep 重复监听 `topicUrls.length` 次 `topic_html` 事件并在所有事件完成后// 再执行后面的回调函数ep.after('topic_html', topicUrls.length, function(topics) &#123; // topics 是个数组，包含 40 次 ep.emit('topic_html', pair) 中的 40 个 pair数组 // map 函数为一个映射，topics 数组里的所有元素都按回调函数处理 topics = topics.map(function (topicPair) &#123; var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; var $ = cheerio.load(topicHtml); return (&#123; // .text() 返回被选元素的文本内容 title: $('.topic_full_title').text().trim(), href: topicUrl, // .eq(0)：将匹配元素集指定 index 上的一个，即拿到Class 'reply_content'的第一个 comment1: $('.reply_content').eq(0).text().trim(), &#125;); &#125;); console.log('final:'); console.log(topics);&#125;);// 全部代码中先执行以下代码，并发请求对应 url 并返回数组topicUrls.forEach(function (topicUrl) &#123; supergent.get(topicUrls) .end(function(err, res) &#123; console.log('fetch' + topicUrl + ' successfully'); ep.emit('topic_html', [topicUrl, res.text]); &#125;);&#125;); 用 cheerio 和 superagent 配合写爬虫 取每个对应标签的属性值1234$(&apos;ClassName&apos;).each(function (idx, element) &#123; var $element = $(element); var href = $element.attr(&apos;href&apos;)&#125;) 爬知乎日报实例12345678910111213141516171819var titles = [];const url = 'daily.zhihu.com';var result = new Promise((resolve, reject)=&gt; &#123; superagent.get(url) .end(function(err, res) &#123; var $ = cheerio.load(res.text); $('.title').each(function(idx, element) &#123; var $element = $(element); // $element.attr('href') var title = $element.text(); titles.push(title); &#125;); resolve(); &#125;);&#125;);result.then(function()&#123; console.log(titles);&#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 语法]]></title>
    <url>%2F2017%2F07%2F22%2Fjs-%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[JS 语法相关问题 变量 函数内部变量不用 var 声明就默认视为 全局变量 回调 1、如果一个函数的参数有回调函数，那么会 先执行完 这个函数再执行回调函数1234567891011121314151617function fun1 (callback)&#123; var e = ...; // 执行一些操作 callback(e);&#125;// 传参方法1，用匿名函数传参fun1(function (var) &#123; console.log(var);&#125;)// 传参方法2，先定义函数后传参function fun2 (var) &#123; console.log(var);&#125;fun1(fun2); 2、如果函数自带回调函数的参数，会先执行完这个函数的全部（包括延迟操作）才执行回调函数123456789101112/*** collection.find().toArray()是个有延迟操作的函数* 必须等到延迟操作完成，即查询完成才会把err，result两个参数返回给回调执行*/collection.find(whereStr).toArray(function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; console.log(result); &#125;); 3、一个函数最后返回的值对下一个函数有用，下一个函数可以加到上一个函数的一个参数（回调函数）内部123456789101112131415161718192021222324252627var MongoClient = require("mongodb").MongoClient;var DB_CNN_STR = 'mongodb://localhost:27017/test'; //连接test数据库Mogoclient.connect(DB_CNN_STR, function(err, db)&#123; // 连接 site 表 var collection = db.collection('site'); collection.find().toArray(function (err, result) &#123; if (err) &#123; console.log(err); return; &#125; console.log(result); &#125;);&#125;);/*** 因为上面返回的 collection 要用作后面的查询* 可以改写为以下*/db.collection('site', function(err, collection) &#123; if(err) throw error; collection.find().toArray(function (err, result) &#123; if(err) throw err; console.log(result); &#125;)&#125;) 异步 js 为单线程异步处理，所以有延迟操作的都会被放入 任务队列 中，异步操作完成后会在 任务队列 放置一个事件，当 主进程完成时 才会去执行 任务队列 中 已完成 并在 等待 的 异步事件 123456789101112131415161718192021// 因为函数内容有回调函数，所以会在等数据库查询操作完成时才会去执行回调函数function foo(callback)&#123; asyncFn(function() &#123; var result = 数据库查询操作; callback(result); &#125;)&#125;/*** 错误例子* asyncFn为一个查询数据库的异步函数，此函数还没执行完就直接执行return* 所以 result 还没被查询出来就被return了*/function foo() &#123; asyncFn(function &#123; var result = 数据库查询操作; &#125;); return result;&#125; Promise 1、用 Promise 解决异步问题，Promise 的三个状态 Pending(等待)， fulfilled(完成)， rejected(失败)帮助更好地执行异步 123456789101112131415161718192021/*** fs.readFile为异步读取文件函数* 如果不用 promise，在fs.readFile函数外直接调用他返回的data，此时data还未被完全读出* 使用 promise，在 promise 回调函数里异步函数在未完成前，promise都处于 "pending" 状态，不会进行下一步操作* 只有当异步完成，成功时调用resolve()，将 Promise状态设为 fulfilled；失败时调用reject()，将 Promise状态设为 rejected* 当状态为 fulfilled 时执行 result.then() 回调函数的内容，函数参数就是 resolve() 的内部参数* 当状态为 rejected 时执行 result.catch() 回调函数的内容，函数参数就是 reject() 的内部参数*/var fs = require("fs");var result = new Promise(function(resolve, reject) &#123; fs.readFile('filename', function(err, data) &#123; resolve(data.toString()); &#125;);&#125;);result.then(function(result)&#123; console.log(result);&#125;).catch(function(err) &#123; console.log(err);&#125;) 2、Promise 写法有两种：123456789// 第一种var result = new Promise(function(resolve, reject) &#123; ...;&#125;)// 第二种var result = new Promise((resolve, reject) =&gt; &#123; ...;&#125;) 3、在 Promise then 中使用 Promise123456789101112131415161718192021/*** 在第一个Promise执行成功后执行他对应的then* fun1 是个 Promise对象（在外部定义），执行成功后返回的 e 传给后面的 then 作为参数* message 是值就是 e 的值*/var result = new Promise(function(resolve, reject) &#123; ...; resolve(d);&#125;);result.then(function(result)&#123; fun1(var1, var2).then(function(message) &#123; console.log(message); &#125;);&#125;);function fun1(var1, var2) &#123; return new Promise(function(resolve, reject) &#123; var e = var1 + var2; resolve(e); &#125;);&#125; 闭包 主要作用：从外部读取函数内部 局部变量 1 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 1234567891011121314151617181920212223242526 var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());// undefined// 外部变量改变了内部属性值，所以 this 指向的原来对象改变，找不到原来对象var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());// My object]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongodb]]></title>
    <url>%2F2017%2F07%2F21%2FMongodb%2F</url>
    <content type="text"><![CDATA[Mongodb相关 启动 Mongodb root用户启动12sudo mongod mongo 普通用户启动123456sudo mongod --authmongo#交互界面use admindb.auth('username', 'password') 创建用户 账号权限只针对数据库，在相应数据库下创建用户，在 test 数据库下创建一个用户123456789&gt; use testswitched to db test&gt; db.createUser(...&#123;...user:"username",...pwd:"password",...roles:[&#123;role:"userAdminAnyDatabase", db:"test"&#125;] ...&#125;...) 角色： Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Express]]></title>
    <url>%2F2017%2F07%2F19%2FNode-js-Express%2F</url>
    <content type="text"><![CDATA[Express 框架应用 路由 123456789101112var express = require("express");var app = express();app.get('/', function(req, res)&#123; console.log("主页 GET 请求"); res.send('Hello GET');&#125;)app.post('/', function(req, res)&#123; console.log("主页 POST 请求"); res.send('Hello POST');&#125;) 静态文件 服务器文件必须跟 public 文件夹在 同一个目录下 设置静态路径方法：1app.use(express.static('public')); 12345678910111213141516var express = require('express');var app = express(); app.use(express.static('public')); app.get('/', function (req, res) &#123; res.send('Hello World');&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 浏览器访问 http://127.0.0.1:8081/images/logo.png GET 方法 12345678910111213141516171819202122232425var express = require("express");var app = express();app.use(express.static('public'));app.get('/index.htm', functino(req, res) &#123; res.sendFile(__dirname + '/' + "index.htm");&#125;)app.get('/process_get', function(req, res) &#123; var response = [ "first_name" : req.query.first_name, "last_name" : req.query.last_name ] console.log(response); res.end(JSON.stringify(response));&#125;)var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) POST 方法 1234567891011121314151617181920212223242526272829var express = require("express");var app = express();var bodyParser = require('body-parser');// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)app.use(express.static('public'));app.get('/index.htm', function(req, res) &#123; res.sendFile(__dirname + '.' + 'index.htm');&#125;)app.post('/process_post', urlencodedParser, function(req, res) &#123; // 输出 JSON 格式 var response = &#123; "first_name" : req.body.first_name, "last_name" : req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;)var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port);&#125;) 文件上传 上传到本地12345678910111213141516171819202122232425262728293031323334var express = require("express");var app = express();var fs = require("fs");var multer = require("multer");app.use(multer(&#123;dest: '/tmp/'&#125;).array('image'));app.get('/index.htm', function(req, res) &#123; res.sendFile(__dirname + '/' + 'index.htm');&#125;)app.post('/file_upload', function(req, res) &#123; console.log(req.files[0]); //上传文件信息 var des_file = __dirname + "/" + req.files[0].originalname; fs.readFile(req.files[0].path, function(err, data) &#123; fs.writeFile(des_file, data, function(err) &#123; if(err) &#123; console.log(err); return; &#125; else &#123; response = &#123; message : 'File uploaded successfully', filename: req.files[0].originalname &#125;; &#125; console.log(response); res.end(JSON.stringify(response)); &#125;); &#125;);&#125;);var server = app.listen(8081);]]></content>
      <categories>
        <category>Express</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Request]]></title>
    <url>%2F2017%2F07%2F19%2FNode-js-Request%2F</url>
    <content type="text"><![CDATA[Node.js GET and POST 参考 http://www.runoob.com/nodejs/node-js-get-post.html GET 1、引入 util 、url 模块2、用 url.parse() 解析 url参数3、url.inspect() 将对象转换为字符串 12345678910var http = require("http");var url = require("url");var util = require("util");http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset=utf-8' &#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 获取URL的参数123456789101112131415var http = require("http");var url = require("url");http.createServer(function(req, res)&#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset = UTF-8' &#125;); // 解析 url 参数 var params = url.parse(req.url, true).query; res.write("网站名: " + params.name); res.write("\n"); res.write("网站URL: " + params.url); res.end();&#125;).listen(3000); POST 1、先用 data 事件监听函数，接收请求体的数据，并累加到变量中2、引入 querystring 模块解析请求体信息3、通过 res.write(变量名.字段名) 引用信息 123456789101112131415161718192021222324252627282930313233var http = require(&quot;http&quot;);var querystring = require(&quot;querystring&quot;);var postHTML = &apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;form method=&quot;post&quot;&gt;&apos; + &apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; + &apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; + &apos;&lt;input type=&quot;submit&quot;&gt;&apos; + &apos;&lt;/form&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;;http.createServer(function(req, res)&#123; var body = &quot;&quot;; req.on(&quot;data&quot;, function(chunk) &#123; body += chunk; &#125;); req.on(&quot;end&quot;, function() &#123; body = querystring.parse(body); if(body.name &amp;&amp; body.url) &#123; res.write(&quot;网站名:&quot; + body.name); res.write(&quot;URL:&quot; + body.url); &#125; else &#123; res.write(postHTML); &#125; res.end(); &#125;);&#125;).listen(3000);]]></content>
      <categories>
        <category>Request</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel-admin]]></title>
    <url>%2F2017%2F07%2F17%2Flaravel-admin%2F</url>
    <content type="text"><![CDATA[laravel-admin 脚手架相关 添加路由 命令会创建路由器文件app/Admin/Controllers/UserController.php1php artisan admin:make UserController --model=App\\User 添加路由配置 在laravel-admin的路由配置文件app/Admin/routes.php里添加一行1$router-&gt;resource('users', UserController::class); 添加菜单链接 打开http://localhost:8000/admin/auth/menu,添加对应的menu 控制展示图片大小 1$grid-&gt;picture()-&gt;image('http://localhost:8000/upload', 100, 100); 展示关联模型 http://z-song.github.io/laravel-admin/#/zh/model-grid?id=%e5%85%b3%e8%81%94%e6%a8%a1%e5%9e%8b form建立一对多 http://z-song.github.io/laravel-admin/#/zh/model-form-fields?id=%e4%b8%80%e5%af%b9%e5%a4%9a 上传图片 1注意创建文件夹 1、创建存储配置，config/filesystems.php 添加一项 disk，设置上传的路径为public/upload：1234567'admin' =&gt; [ 'driver' =&gt; 'local', 'root' =&gt; public_path('upload'), 'visibility' =&gt; 'public', ],``` 2、选择上传的`disk`，修改`config/admin.php` ‘upload’ =&gt; [ &apos;disk&apos; =&gt; &apos;admin&apos;, &apos;directory&apos; =&gt; [ &apos;image&apos; =&gt; &apos;image&apos;, &apos;file&apos; =&gt; &apos;file&apos;, ], &apos;host&apos; =&gt; &apos;http://localhost:8000/upload/&apos;, ],```]]></content>
      <categories>
        <category>admin</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 语法]]></title>
    <url>%2F2017%2F07%2F06%2FPython-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python 语法相关 格式化输出 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' lists(列表) 1、lists中有lists可以看为二维数组1234&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']&gt;&gt;&gt; s[2][0]'asp' tuple(元组) 一旦初始化不能修改(tuple的每个元素指向不变)1、如果要定义一个元素的 tuple，要用,123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 2、tuple 中的 lists 可变12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) dict（字典） 1、关联数组2、key必须是不可变的对象 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 判断 key 是否存在12&gt;&gt;&gt; 'Thomas' in dFalse set 1、是一组key的集合，但是不存储values（key不能重复，重复元素在set中被自动过滤）2、创建一个set，提供一个list作为集合123&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 3、可以对两个set进行交集，并集等操作123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 判断语句 不要忘记加’：’1、常规 if else1234567age = 3if age &gt;= 18: print('your age is', age) print('adult')else: print('your age is', age) print('teenager') 2、elif1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环 for in依次把 list 或 tuple 中的每个元素迭代出来123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) while123while n &gt; 0: sum = sum + n n = n - 2 for循环引用两个变量123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 函数 1、函数名可以赋值给变量123&gt;&gt;&gt; a = abs &gt;&gt;&gt; a(-1) 1 2、从其他文件导入函数1from fileName import functionName 3、函数名也是变量 如果将函数名指向其他对象，函数将不能被正常调用，要恢复要重启交互环境12345&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'int' object is not callable 由于 abs 函数实际上是定义在 import builtins 模块中的，所以要让修改 abs 变量的指向在其它模块也生效，要用 import builtins; builtins.abs = 10 4、空函数pass 用作占位符，没有 pass 代码会运行错误12def nop(): pass pass 用在其他语句中12if age &gt;= 18: pass 5、函数返回多个值5.1 允许对左边两个变量赋值1x, y = func(para) #函数返回两个值 5.2 函数返回多个值返回的其实是一个tuple12345678910111213import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y + step * math.sin(angle) return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x,y)151.96152422706632 70.0&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 6、函数执行完毕也没有 return 语句时，自动 return None7、函数参数的默认值7.1 基本使用12345def func(x, y, n=1, m='string'): pass#如果不按顺序传默认值参数要把参数名写上func(1, 2, m='guangZhou') 7.2 默认参数必须指向不变对象（以下示例默认参数的坑） 1234567891011121314151617def add_end(L=[]): L.append('END') return L&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END']#默认参数变量L指向一个list，但是list是可变的，每次调用函数都改变了变量L指向的list，所以下次调用的时候默认参数已经改变def add_end(L=None): if L is None: L = [] L.append('END') return L 8、可变参数（参数为tuple\list）*nums 表示把 nums 这个 list 的所有元素作为可变参数传进去12345678910111213141516#在参数前加一个*号，在函数内部参数接收到的是一个tupledef calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0#在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 9、关键字参数（参数为dict）关键字参数允许传入0个或任意个 含参数名 的参数，这些关键字参数在函数内部自动组装为一个 dict1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)# 1、只传入必选参数&gt;&gt;&gt; person('Nancelglap', 18)name: Nancelglap age: 30 other: &#123;&#125; # 2、传入任意个数的 关键字参数&gt;&gt;&gt; person('Nancelglap', 18, city='huizhou', sex='Male')name: Nancelglap age: 18 other: &#123;'city': 'huizhou', 'sex': 'Male'&#125;# 3、先定义一个dict，把dict转换为 关键字参数 传进去&gt;&gt;&gt; extra = &#123;'city': 'Huizhou', 'sex': 'Male'&#125;&gt;&gt;&gt; person('Nancelglap', 18, city=extra['city'], sex=extra['sex'])name: Nancelglap age: 18 other: &#123;'city': 'Huizhou', 'sex': 'Male'&#125;# 4、简化3的调用# **extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 **kw参数，kw将获得一个dict# kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra&gt;&gt;&gt; extra = &#123;'city': 'Huizhou', 'sex': 'Male'&#125;&gt;&gt;&gt; person('Nancelglap', 18, **extra)name: Nancelglap age: 18 other: &#123;'city': 'Huizhou', 'sex': 'Male'&#125;# 5、限制关键字参数的名字（命名关键字参数）# 命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数# 只接收city和job作为关键字参数def person(name, age, *, city, job): print(name, age, city, job)# 6、可变参数 + 命名关键字参数# 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*# 调用时不加参数名会被视为位置参数报错def person(name, age, *args, city, job) print(name, age, args, city, job)&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given# 7、命名关键字参数缺省值# 命名关键字参数有默认值，调用时可不传入参数def person(name, age, *, city='Beijing', job): print(name, age, city, job)&gt;&gt;&gt; person('Jack', 24, job='Engineer')Jack 24 Beijing Engineer 使用命名关键字参数，如果没有可变参数，必须加一个’*’，否则会被认为位置参数 10、参数组合参数定义顺序：必选参数,默认参数,可变参数,命名关键字参数,关键字参数1234567891011121314151617181920212223242526# a、b：必选参数 c：默认参数 args：可变参数 kw：关键字参数def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)# a、b：必选参数 c：默认参数 d：命名关键字参数 kw：关键字参数def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125;# 通过 tuple 和 dict 调用上述函数&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 对于任意函数，都可以通过类似func(args, *kw)的形式调用它，无论它的参数是如何定义的。 高阶函数 一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。123456def add(x, y, f): return f(x) + f(y)# 交互&gt;&gt;&gt; add(-5, 6, abs)11 函数作为返回值 1、闭包（Closure）-&gt; 在函数 lazy_sum 中又定义了函数 sum-&gt; 内部函数 sum 可以引用外部函数lazy_sum 的参数和局部变量-&gt; 当 lazy_sum 返回函数 sum 时，相关参数和变量都保存在返回的函数中 2、当我们调用 lazy_sum()时，每次调用都会返回一个 新的函数，即使传入相同的参数：1234567891011121314151617def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum# 交互&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False 闭包 1、当一个函数返回一个函数后，其内部变量还被新函数引用2、返回的函数没有立刻执行，直到调用 f() 才执行3、返回的函数内部不要引用局部变量，当最后调用 f() 的时候 局部变量可能已经不是当初定义函数时候的值123456789101112131415161718def count(): fs = [] for i in range(1, 4): # 每次循环创建一个新的函数 def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()# f1(), f2(), f3()调用的结果并不是当时定义时返回的1、4、9# 返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 4、如果一定要引用循环变量，再创建一个函数，用该函数的参数绑定循环变量当前值5、闭包可以理解为两个过程 传值调用 和 启动，当有参数传进外部函数时，第一个过程完成，当用 f() 时为启动这个闭包，会接着执行内部函数的内容6、闭包必须先 传值调用 后赋给另一个变量，然后在启动变量调用内部函数123456789def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 切片 切片可以对 lists、tuple、string 进行操作 1、传统取 list 或 tuple 的部分元素操作123456789&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n);... r.append(L[i])...&gt;&gt;&gt;&gt; r['Michael', 'Sarah', 'Tracy'] 2、基本切片（1）[n ,m]：从索引 n 开始，知道索引 m ，但不包括索引 m（2）如果第一个索引是 0，可以省略：[:3] 3、倒数切片（1）L[-2:-1]取倒数第二个元素（2）L[-2:]取倒数两个元素 4、间隔切片（1）L[::5]：所有数每5个取一个（2）L[:10:2]：前10个数每两个取一个 迭代 1、迭代 dict 的 key（取出所有key）1234567&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; L = []&gt;&gt;&gt; for key in d:... L.append(key)...&gt;&gt;&gt; L[a, b, c] 2、迭代 dict 的 valuefor value in d.values() 123456&gt;&gt;&gt; values = []&gt;&gt;&gt; for v in d.values():... values.append(v)...&gt;&gt;&gt; values[1, 2, 3] 3、同时迭代 key 和 valuefor k, v in d.items() 12345678910&gt;&gt;&gt; keys = []&gt;&gt;&gt; values = []&gt;&gt;&gt; for k, v in d.items():... keys.append(k)... values.append(v)...&gt;&gt;&gt; keys['a', 'b', 'c']&gt;&gt;&gt; values[1, 2, 3] 4、判断一个对象是否为可迭代对象通过collections模块的Iterable类型判断1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance([1,2,3], Iterable)True&gt;&gt;&gt; isinstance(123, Iterable)False 列表生成式 1、基本列表生成式[操作式 for x in 可迭代对象]12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 2、加判断的列表生成式[操作式 for x in 可迭代对象 if 判断条件]12&gt;&gt;&gt; [x * x for x in range(1,11) if x % 2 == 0][4, 16, 36, 64, 100] 3、两层循环，生成全排列[操作式 for n in 可迭代对象1 for m in 可迭代对象2]12&gt;&gt;&gt; [n + m for n in 'ABC' for m in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 4、运用示例（列出当前目录下的所有文件和目录名）12&gt;&gt;&gt; import os&gt;&gt;&gt; [d for d in os.listdir('.')] 5、优化迭代 dict 的 key 和 value123&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.iterms()]['y=B', 'x=A', 'z=C'] 生成器（generator） 1、作用：节省列表中没必要的空间2、创建一个有很多元素的列表会占用很大的存储空间，如果列表元素可以按某种算法推算出来，就可以在循环中不断推出后面的元素3、generator 保存的是算法4、每次调用 next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的错误5、生成方法：把一个列表生成式的 [] 改成 ()123456789&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;# 一般调用&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1 6、循环调用(用 for 循环)1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)...0149162536496481 7、函数变 generator（1）如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个 generator1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' （2）函数内部遇到 yield 语句的时候返回，再次执行从上次返回的 yield 处继续执行1234567def odd(): print('step 1') yield 1 print('step 2') yield 3 print('step 3') yield 5 (3)当用 for 循环迭代的时候，yield 可以看做将内容存在待用列表中123456789&gt;&gt;&gt; for n in fib(6):... print(n)...11q2358 （4）for 循环调用 generator 时，拿不到 generator 的 return 语句的返回值，如果想要拿到返回值，要捕获 StopIteration 错误，返回值包含在 StopIteration 的 value 中12345678910111213141516&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print('g:', x)... except StopIteration as e:... print('Generator return value:', e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 迭代器 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 一、可以直接作用于 for 循环的对象统称为可迭代对象： Iterable1、一类是集合数据类型，如 list、tuple、dict、set、str等2、一类是 generator，包括生成器和带 yield 的 generator function 二、generator 都是 Iterator 对象，但 list、dict、str 虽然是 Iterable，却不是 Iterator1234567&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 三、可以通过 iter() 函数将 Iterable 转换为 Iterator12&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 四、Iterable 和 Iterator 小结1、凡是可作用于 for 循环的对象都是 Iterable 类型2、凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列（只有需要返回下一个数据时才会计算） 五、for 循环的本质通过不断调用 next() 函数实现1234567891011for x in [1, 2, 3, 4, 5]: pss# 上面等价于以下it = iter([1, 2, 3, 4, 5])while True: try: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 抛出错误 raise TypeError(&#39;Error message&#39;)12if not isinstance(x, (int, float)): raise TypeError('bad operand type')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 相关]]></title>
    <url>%2F2017%2F07%2F06%2FPython-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[与 python 相关知识 一、保存文件 当 .py 文件中包含中文，在文件开头加上两行1、第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序2、第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。12#!/usr/bin/env python3# -*- coding: utf-8 -*- 二、序列 python包含 6 中内建的序列，包括列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。 三、不变对象 不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。 四、计算机（Computer）和计算（Compute） 1、在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。2、而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。3、对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。 五、函数式编程 1、函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。2、任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。3、允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。4、函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数]]></title>
    <url>%2F2017%2F07%2F06%2FPython-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python 函数 lists 函数 list() 1、将序列转换成 list2、将 Iterator 计算出整个序列并返回一个 list name.append() 往lists中追加元素到末尾123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam'] name.pop() 1、没加参数删除末尾元素，有参数删除索引位置的元素2、list 不能传 字符串 参数，dict 可以 12&gt;&gt;&gt; classmates.pop(1)'Jack' name.insert() 把元素插到指定位置123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] name.sort() 对序列内容排序 enumerate() 把一个 list 变成 索引-元素对 ，可以在 for 循环中同时迭代索引和元素本身123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C len() 计算列表元素个数 dict函数 get() 如果 key 不存在，可以返回自定义的内容123&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', 'not found')'not found' pop() 删除一个 key set函数 add(key) 添加元素到 set 中123&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; remove(key) 删除元素123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; 常见函数 ord() 获取字符的整数表示1234&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013 chr() 把编码转换为对应的字符12&gt;&gt;&gt; chr(66)'B' int() 将数字字符串转换为整数（’123’） range() 生成一个从零开始到参数的序列（不包括参数）12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] str.replace(‘被替代的内容’, ‘要替代的内容’) 1、替代字符串的内容，但是不改变原有的字符串2、其实是创建一个新的字符串返回123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = a.replace('a', 'A')&gt;&gt;&gt; b'Abc'&gt;&gt;&gt; a'abc' count() 统计字符串里某个字符串出现的次数，可指定参数在字符串中的开始和结束位置str.count(sub, start, end) iter() 把 list、dict、str 等 Iterable 变成 Iterator123&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 数据类型相关 abs() 求绝对值 int() float() str() bool() 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False isinstance() 数据类型检查1isinstance(x, (int, float)) 高阶函数 map() 1、map() 接收两个参数，一个是函数，一个是 Iterable，map 将传入的函数依次作用到序列的每个元素，并将结果作为新的 Iterator 返回2、map() 函数返回的是一个 Iterator，是一个惰性序列，要用 list() 函数获得所有结果并返回 list3、参数函数接收一个参数，返回的是对这个参数操作后的值 1234567891011# 1、函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]# 2、把 list 所有数字转为字符串&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6]))['1', '2', '3', '4', '5', '6'] reduce() 1、reduce() 把一个函数作用在一个序列上，reduce 把结果继续和序列下一个元素做积累计算2、函数必须接收两个参数，返回的是对两个参数的操作1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 结合 map() 和 reduce() 写把 str 转换成 int 的函数12345678from functools import reducedef str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s] return reduce(char2num, map(fn, s)) filter() 1、接收一个函数和一个序列，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素2、参数函数 返回值 必须是 bool值3、filter() 函数返回的是一个 Iterator，也就是一个惰性序列，所以要强迫 filter() 完成计算结果，需要用 list()函数获得所有结果并返回 list 123456# 在一个list中只保留奇数def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果：[1, 5, 9, 15] 把一个序列中的空字符串删掉：12345def not_empty(s): return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' '])) #多个空格为bool值为True# 结果：['A', 'B', 'C'] sorted() 函数参数返回一个要排序的内容 1、普通排序12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 2、接收一个 key函数 实现自定义排序（返回结果不做传入函数的处理）12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] 3、字符串排序1234567891011# 根据`ASCII`大小比较，大写字母`小于`小写字母&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob']# 忽略大小写的排序&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo']# 反向排序，传入第三个参数reverse=True&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about']]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 定时备份]]></title>
    <url>%2F2017%2F06%2F20%2Fmysql-%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[实现mysql定时备份 1、创建备份文件夹1mkdir name 2、创建备份Shell脚本1$ vim filename.sh 3、加入以下内容（1）username 替换为实际的用户名(保留-u)（2）password 替换为实际的密码（保留-p）（3）DatabaseName 替换为实际的数据库名（4）/home/back改为自己的路径12#!/bin/bashmysqldump -uusername -ppassword DatabaseName &gt; /home/backup/DatabaseName_$(date +%Y%m%d_%H%M%S).sql 4、添加可执行权限1$ chmod u+x bkDatabaseName.sh 5、添加计划任务（改为自己创建的文件信息）123$ crontab -e*/1 * * * * /home/backup/bkDatabaseName.sh 6、执行时间前面五个*号代表五个数字，数字的取值范围和含义如下： 分钟 （0-59）小時 （0-23）日期 （1-31）月份 （1-12）星期 （0-6）//0代表星期天]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[微信公众号开发相关 参考资料：https://easywechat.org/https://github.com/overtrue/laravel-wechat 配置 1、注册相应路由和创建 Controller12345678910111213class WechatController extends Controller&#123; public function serve() &#123; $wechat = app('wechat'); $wechat-&gt;server-&gt;setMessageHandler(function($message)&#123; return "您好！欢迎关注我!"; &#125;); return $wechat-&gt;server-&gt;serve();&#125; 2、改 接口授权 -&gt; 网页授权获取用户基本信息 url 为服务器的域名 返回信息类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App\Http\Controllers;class WechatController extends Controller&#123; /** * 处理微信的请求消息 * * @return string */ public function serve() &#123; $wechat = app('wechat'); $userApi = $wechat-&gt;user; $wechat-&gt;server-&gt;setMessageHandler(function($message) use ($userApi)&#123; switch ($message-&gt;MsgType) &#123; case 'event': return '收到事件消息'; break; case 'text': return $userApi-&gt;get($message-&gt;FromUserName)-&gt;nickname; break; case 'image': return '收到图片消息'; break; case 'voice': return '收到语音消息'; break; case 'video': return '收到视频消息'; break; case 'location': return '收到坐标消息'; break; case 'link': return '收到链接消息'; break; // ... 其它消息 default: return '收到其它消息'; break; &#125; &#125;); return $wechat-&gt;server-&gt;serve(); &#125;&#125; 操作用户信息 1、自行完成路由注册，Controller 创建等操作2、更多用户操作见文档 https://easywechat.org/zh-cn/docs/user.html1234567891011121314151617181920212223242526272829303132333435363738394041use EasyWeChat\Foundation\Applications;class ControllerName extends Controller&#123; public $wechat; public function __construct(Applications $wechat) &#123; $this-wechat = $wechat; &#125; /** * 返回所有关注用户的openId */ public function users() &#123; $users = $this-&gt;wechat-&gt;user-&gt;lists(); return $users; &#125; /** * 返回单个已关注用户的信息 */ public function user($openId) &#123; $user = $this-&gt;wechat-&gt;user-&gt;get($openId); return $user; &#125; /** * 修改用户备注 （remark方法） */ public function remark($openId) &#123; $this-&gt;wechat-&gt;remark($openId, '备注信息'); return 'OK'; &#125;&#125; 管理公众号素材 1、自行注册路由和创建 Controller2、参考文档内容https://easywechat.org/zh-cn/docs/material.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253use EasyWeChat\Foundation\Applications;class ControllerName extends Controller&#123; public $material; public function __construct(Applications $material) &#123; $this-material = $material-&gt;material; &#125; /** * 上传public目录下的图片 */ public function image() &#123; $image = $this-&gt;material-&gt;uploadImage(public_path(). '/images/imageName.jpg'); return $image; &#125; /** * 上传public目录下的音频 */ public function audio() &#123; $audio = $this-&gt;material-&gt;uploadVoice(public_path. '/images/audioName.mp3'); //注意支持的格式 return $audio; return $user; &#125; /** * 查看所有上传了的图片信息 */ public function materials() &#123; $materials = $this-&gt;material-&gt;lists('image'); //返回其他素材看文档 return $materials; &#125; /** * 拿到特定素材信息 */ public function media($mediaId) &#123; $media = $this-&gt;material-&gt;get($mediaId); return $media; &#125;&#125; 3、当用户发音频信息，以客服身份返回信息（其他类型的信息类似）1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\Http\Controllers;class WechatController extends Controller&#123; /** * 处理微信的请求消息 * * @return string */ public function serve() &#123; $wechat = app('wechat'); $userApi = $wechat-&gt;user; $wechat-&gt;server-&gt;setMessageHandler(function($message) use ($userApi, $wechat)&#123; switch ($message-&gt;MsgType) &#123; ... case 'voice': $message = new Voice(['media_id'] =&gt; '要返回的mediaId值'); //$message-&gt;FromUserName拿到用户的openId $wechat-&gt;staff-&gt;message($message)-&gt;to($message-&gt;FromUserName)-&gt;send(); return 'string'; break; ... &#125; &#125;); return $wechat-&gt;server-&gt;serve(); &#125;&#125;]]></content>
      <categories>
        <category>Wechat</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ACL]]></title>
    <url>%2F2017%2F06%2F16%2FLaravel-ACL%2F</url>
    <content type="text"><![CDATA[Laravel 实现 Access Control Lists ACL权限 1、生成测试数据1234/*** modelFactory，生成用户自己的文章*/'user_id' =&gt; factory(App\User::class)-&gt;create()-&gt;id, 2、修改 AuthServiceProvider 中的 boot 方法12345678910111213141516171819202122232425262728293031use Illuminate\Contracts\Auth\Access\Gate as GateContract;public function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); $gate-&gt;define('show-post', function($user, $post)&#123; //登录来的用户id必须等于文章的user_id才有权限查看 return $user-&gt;id === $post-&gt;user_id; //$user为登录进来的用户，laravel自动检测 &#125;)&#125;/*** 对上述代码进行优化*///AuthServiceProvider.phppublic function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); $gate-&gt;define('show-post', function($user, $post)&#123; return $user-&gt;owns($post); &#125;)&#125;//User.phppublic function owns($post)&#123; return $this-&gt;id == $post-&gt;user_id;&#125; 3、在 controller 中应用认证123456789101112131415use Gate;public function show($id)&#123; $post = Post::findOrFail($id); Auth::loginUsingId(2); if(Gate::denies('show-post', $post))&#123; //show-post为在AuthServiceProvider中定义的名称 abort(403, 'Sorry'); //如果认证失败就返回403页面 &#125; //如果不用上面if方法，可以用以下 $this-&gt;authorize('show-post', $post); return $post-&gt;title;&#125; 4、在 blade 中应用认证（@can()标签）1234&lt;!-- 定义了 'show-post' 后只有传进来的$post符合验证规则才会显示标签内内容 --&gt;@can('show-post', $post)&lt;a href="#"&gt;...&lt;/a&gt;@endcan 实现多个ACL权限 1、创建一个 与相应 model 对应的 policy1php artisan make:policy policyName 2、编写 app\Policies\policyName，在里面增加函数完成权限操作12345678910use App\User;use App\Post;...public function method(User $user, Post $post)&#123; return $user-&gt;owns($post); //owns在User的model中定义&#125; 3、启用 policy：在AuthServiceProvider 中的 $policies 数组中注册123456789protected $policies = [ /** * 在Controller中用Gate::denies('method', $post) * 根据第二个参数的类决定用哪个policy验证 * 再根据第一个参数用相应policy的method方法验证 */ 'App\Post' =&gt; 'App\Policies\PolicyName',]; 4、运用 policy123456789101112131415161718192021222324/*** 去掉AuthServiceProvider中的以下部分*/$gate-&gt;define('show-post', function($user, $post)&#123; return $user-&gt;owns($post); &#125;)；/*** 修改Controller中的方法*/public function show($id)&#123; $post = Post::findOrFail($id); Auth::loginUsingId(2); //method为$post类对应的policyName中的验证函数 if(Gate::denies('method', $post))&#123; abort(403, 'Sorry'); &#125;&#125;/*** 如果blade中有@can标签，将参数改为验证函数名*/ 创建model和表 1、创建 Permission 和 Role model12345//权限php artisan make:model Permission//角色（规定某种权限）php artisan make:model Role 2、创建相应的表1php artisan make:migration create_roles_table --create=roles 3、编写 migration 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public function up()&#123; Schema::create('roles', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); //admin, member $table-&gt;string('label')-&gt;nullable(); //desription of name $table-&gt;timestamps(); &#125;); Schema::create('permissions', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); //admin, member $table-&gt;string('label')-&gt;nullable(); //desription of name $table-&gt;timestamps(); &#125;); /** * 关联 roles 和 permissions 表 */ Schema::create('permissions_role', function (Blueprint $table) &#123; $table-&gt;integer('permission_id')-&gt;unsigned(); $table-&gt;integer('role_id')-&gt;unsigned(); //创建外键 $table-&gt;foreign('permission_id') -&gt;references('id') -&gt;on('permissions') -&gt;onDelete('cascade'); $table-&gt;foreign('role_id') -&gt;references('id') -&gt;on('roles') -&gt;onDelete('cascade'); $table-&gt;primary(['permission_id', 'role_id']); //联合主键，只要两条数据两个字段不一样就行 &#125;); /** * 关联 roles 和 users 表 */ Schema::create('role_user', function (Blueprint $table) &#123; $table-&gt;integer('user_id')-&gt;unsigned(); $table-&gt;integer('role_id')-&gt;unsigned(); //创建外键 $table-&gt;foreign('user_id') -&gt;references('id') -&gt;on('users') -&gt;onDelete('cascade'); $table-&gt;foreign('role_id') -&gt;references('id') -&gt;on('roles') -&gt;onDelete('cascade'); $table-&gt;primary(['user_id', 'role_id']); //联合主键，只要两条数据两个字段不一样就行 &#125;);&#125; 4、执行 php artisan migrate 创建表之间的多对多关系 user: 用户，用户自己注册的账户，通过与role表的联系赋予用户角色（角色表与permission联系赋予用户权限） role：角色（admin, user等），用来描述user在该项目中的角色 permissions: 权限，用来描述一个角色拥有的权限，比如edit_form 1、修改 model 文件1234567891011121314151617181920212223242526272829/*** Permission*/public function roles()&#123; return $this-&gt;belongsToMany(Role::class);&#125;/*** Role*/public function permissions()&#123; return $this-&gt;belongsToMany(Permission::class);&#125;public function givePermission(Permission $permission)&#123; return $this-&gt;permissions()-&gt;save($permission); //通过 $role-&gt;givePermission($permission) 给角色权限&#125;/*** User*/public function roles()&#123; return $this-&gt;belongsToMany(Role::class);&#125; 2、进入 tinker 创建一个 role 角色和一个 permission 权限123456789101112131415161718php artisan tinker/*** 创建 role 为 admin*/namespace App;$role=new Role;$role-&gt;name="admin"; //角色名$role-&gt;label="Admin"; //角色描述$role-&gt;save();/*** 创建 permission 为 edit_form*/$permssion = new Permission;$permission-&gt;name = "edit_form"; //权限名$permission-&gt;label = "Edit the form"; //权限解释$permission-&gt;save(); 创建 权限 和 角色 后在 permission_role 中并没有将两个相关联 3、关联 权限 和 角色12//接着上面的tinker界面$role-&gt;givePermission($permission); //关系表中会生成自动关联数据 4、定义 权限1234567891011121314151617181920212223242526272829303132333435363738394041/*** AuthServiceProvider*/public function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); foreach($this-&gt;getPermissions() as $permission) &#123; $gate-&gt;define($permissions-&gt;name, function(User $user) use ($permission)&#123; return $user-&gt;hasRole($permission-&gt;roles); &#125;); &#125;&#125;protected function getPermissions()&#123; return Permission::with('roles')-&gt;get();&#125;/*** User model*/public function hasRole($role)&#123; /** * 在其他地方使用，如果传hasRole('admin')，既传进来的是字符串 */ if(is_string($role)) &#123; //判断user的所有role中是否存在name为$role的 return $this-&gt;roles-&gt;contains('name', $role); &#125; /** * 本例中使用，传进来的是roles的Collection */ // 1、判断user的role是否有与permission的role相同的 // 2、count返回 &gt;0 表明有用户有这个权限，取反再取反返回真 // 3、count返回 0 表明用户没有这个权限，取反再取反返回假 // 4、注意roles不要加括号，intersect方法处理的是Collection return !! $role-&gt;intersect($this-&gt;roles)-&gt;count(); &#125; 5、blade 应用1234&lt;!--在 AuthServiceProvider 中已经foreach注册了权限--&gt;@can('权限名')...@endcan 6、示例：赋予用户一个角色，让他拥有一定权限1234567php artisan tinkernamespace App;$user = User::find(1);$role = Role::find(1);$user-&gt;roles()-&gt;save($role); 7、应用实例：当用户注册时候自动赋予某个角色（角色和权限已经先在数据库定义好关系）123456789101112/*** 在 Controller 中*/public function register(RegisterRequest $request)&#123; $user = User::create($data); $role = Role::where('name', 'ordinary_user'); // 给注册用户 ordinary_user 这个角色 // 他的权限就是 ordinary_user 拥有的权限（在数据库预先定义好） $user-&gt;roles()-&gt;save($role);&#125; 使用 Middleware 实现后台管理 部分实现条件参考上面内容 1、创建 middleware1php artisan make:middleware NameOfMiddleware 2、在 middleware 的 handle 方法中实现代码逻辑123456789101112131415161718public function handle($request, Closure $next)&#123; //$request-&gt;user()就是Auth::user()作用 if($request-&gt;user() &amp;&amp; $request-&gt;user()-&gt;isAdmin()) &#123; return $next($request); &#125; //没通过认证就重定向回首页 return redirect('/');&#125;/*** 到 User model 中声明 isAdmin()方法*/public function isAdmin()&#123; return $this-&gt;hasRole('admin'); //hasRole参考上面内容&#125; 3、注册 middleware1234567/*** app\Http\Kernel.php*/protected $routeMiddleware = [ ... 'name' =&gt; \App\Http\Middleware\NameOfMiddleware::class,] 4、使用 middleware1234567891011121314151617181920/*** 方法一：在 Route 中使用* name 是在注册时规定的名称*/Route::get('/', ['middleware' =&gt; 'name'], function() &#123; ...;&#125;)/*** 方法二：在 Controller 中使用* 在 __construct() 中使用*/public function __construct()&#123; //name 是在注册时规定的名称 $this-&gt;middleware('name'); //指定只有几个方法运用middleware $this-&gt;middleware('name', ['only' =&gt; ['store', 'update']]);&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>ACL</tag>
        <tag>authorize</tag>
        <tag>Middleware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 项目实战相关]]></title>
    <url>%2F2017%2F06%2F12%2FLaravel-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[与 Laravel 实际项目相关内容 在Controller中重定向Controller中的方法 1return redirect()-&gt;action('NameController@method', ['param' =&gt; 'value']); 在 Controller 中使用 middleware 123456789101112/*** Controller*/public function __construct()&#123; $this-&gt;middleware('auth', ['only' =&gt; ['create', 'store', 'edit', 'update']]); //只用在四种方法上&#125;/*** app\Http\Middleware\Authenticate.php*/return redirect()-&gt;guest('返回的路由'); 更新数据内容 将原来的内容填入编辑表单中（使用Form::model）123456789/*** edit.blade.php*/&#123;&#123; Form::model($comment, ['method' =&gt; 'post', 'url' =&gt; '/comment/'.$comment-&gt;id]) &#125;&#125;/*** 点击更改的url'/comment/edit/$comment-&gt;id'，* Route::post('/comment/edit/&#123;id&#125;')*/ 更新数据方法12$comment = comment::findOrFail($id);$comment-&gt;update($request-&gt;all()); 设置只有发表评论的人才能更新123456789101112131415161718/*** Controller*/public function edit($id)&#123; $comment = comment::findOrFail($id); if(Auth::user()-&gt;id !== $comment-&gt;user_id) &#123; return redirect('/'); &#125;&#125;/*** Blade*/@if(Auth::check() &amp;&amp; Auth::user() -&gt; id == $comment-&gt;user_id) ...@endif 实现评论一：创建表以及完成之间的联系 1、migration 文件的设置123456789101112131415161718/*** comment表*/$table-&gt;increments('id');$table-&gt;text('body');$table-&gt;integer('user_id')-&gt;unsigned();$table-&gt;integer('discussion_id')-&gt;unsigned();//创建外键$table-&gt;foreign('user_id') -&gt;references('id') //连接的主键字段为id -&gt;on('users') //连接的表为users -&gt;onDelete('cascade');$table-&gt;foreign('discussion_id') -&gt;references('id') -&gt;on('discussions') -&gt;onDelete('cascade');$table-&gt;timestamps(); 2、 model 文件建立联系123456789101112131415161718192021222324252627282930313233/*** User model*/public function discussions()&#123; return $this-&gt;hasMany(Discussion::class); //$user-&gt;disscussions拿到所有发布&#125;public function comments()&#123; return $this-&gt;hasMany(Comment::class); //$user-&gt;comments拿到所有评论&#125;/*** Comment model*/public function disscussion()&#123; return $this-&gt;belongsTo(User::class);&#125;/*** Discussion model*/public function user()&#123; return $this-&gt;belongsTo(User::class);&#125;public function comments()&#123; return $this-&gt;hasMany(Comment::class);&#125; 实现评论二、存储评论 并 限制展示评论框 1、评论存储要带上依附内容的 id 存入数据库1234567/*** 1、评论提交的时候就要带上文章内容的id，可以用隐藏表单（数据库中要有这个字段）* 2、存入数据库带上评论用户的id*/&#123;!! Form::hidden('id', $article-&gt;id) !!&#125;Comment::create(array_merge($request-&gt;all(), ['user_id' =&gt; Auth::user()-&gt;id])); 2、如果用户没有登录不展示评论框12345678/*** blade */@if(Auth::check()) ... //展示评论框@else &lt;a href="/user/login" class="btn btn-block btn-success"&gt;登录&lt;/a&gt;@endif 实现下拉菜单 123456789101112131415161718192021&lt;!--app.blade.php--&gt;&lt;link rel="stylesheet" href="/css/bootstrap.css"&gt;&lt;link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;link rel="stylesheet" href="/css/style.css"&gt;&lt;li&gt; &lt;a id="dLabel" type="button" data-toggle="dropdown" aria-haspopup="ture"&gt; &#123;&#123; Auth::user()-&gt;name &#125;&#125; &lt;/a&gt; &lt;ul class="dropdown-menu" aria-labelledby="dLabel"&gt; &lt;li&gt;&lt;a href="#"&gt; &lt;i class="fa fa-user"&gt;&lt;/i&gt; 更换头像&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; &lt;i class="fa fa-cog"&gt;&lt;/i&gt; 更换密码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; &lt;i class="fa fa-heart"&gt;&lt;/i&gt; 特别感谢&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="/logout"&gt; &lt;i class="fa fa-sign-out"&gt;&lt;/i&gt; 退出登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;script src="//cdn.bootcss.com/jquery/3.0.0-alpha1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"&gt;&lt;/script&gt; 集成 markdown 编辑器 1、在 composer.json 的require里加入，执行composer update1"yuanchao/laravel-5-markdown-editor": "dev-master" 2、在 config/app.php 的 providers 数组加入一条1'YuanChao\Editor\EndaEditorServiceProvider' 3、在 config/app.php 的 aliases 数组加入一条1'EndaEditor' =&gt; 'YuanChao\Editor\Facade\EndaEditorFacade' 4、执行 php artisan vendor:publish --tag=EndaEditor 5、修改需要编辑器的页面12345678//引入编辑器代码，必须在引入头文件前引入jquery文件！！！！&lt;script src="//cdn.bootcss.com/jquery/3.0.0-alpha1/jquery.min.js"&gt;&lt;/script&gt; @include('editor::head')//创建一个 class 为 editor 的容器&lt;div class="editor"&gt; &#123;!! Form::textarea('content', '', ['class' =&gt; 'form-control','id'=&gt;'myEditor']) !!&#125;&lt;/div&gt; 以下为配置图片上传6、修改 \config\editor.php，并注册路由12345//修改config\editor.php配置'uploadUrl' =&gt; 'post/upload' //放到PostsController中//注册路由Route::post('/post/upload', 'PostsController@upload'); 7、在 PostsController 中创建 upload 方法1234567use EndaEditor; //在头部加上public function upload()&#123; $data = EndaEditor::uploadImgFile('uploads'); //上传目录为\public\uploads return json_encode($data); &#125; 8、如果出现上传图片时候黑屏，删掉 resource\views\vendor\editor\head.blade.php 中的1&lt;script src="....bootstrap.js"&gt;&lt;/script&gt; 引用 Markdown 和第三方库 1、复制https://github.com/SegmentFault/HyperDown Parser.php 文件2、创建一个 Class app\Markdown\Parser.php，将复制的代码粘贴进去，声明命名空间1namespace App\Markdown; 3、创建一个 Class app\Markdown\Markdown.php1234567891011121314151617class Markdown &#123; protected $parser; public function __construct(Parser $parser) &#123; $this-&gt;parser = $parser; &#125; public function markdown($text) &#123; $html = $this-&gt;parser-&gt;makeHtml($text); return $html; &#125;&#125;//将新文件加载到autoload文件里面composer dump-autoload 4、在 Controller 中引入 Markdowwn 类123456789101112131415161718192021use App\Markdown\Markdown;class NameController extends Controller&#123; protected $markdown; public function __construct(Markdown $markdown) &#123; $this-&gt;markdown = $markdown; &#125; /** * 在某个展示方法中使用 */ public function show($id) &#123; $comment = comment::findOrFail($id); $html = $this-&gt;markdown-&gt;markdown($comment-&gt;content); return view('show', compact('comment', 'html')); &#125;&#125; 5、在 blade 文件中输出内容1&#123;&#123; $html &#125;&#125; 实现收藏内容功能 1、创建关系表1234567php artisan make:model Favorite -m/*** migration*/$table-&gt;integer('user_id')-&gt;unsigned();$table-&gt;integer('article_id')-&gt;unsigned(); 2、建立多对多关系12345678/*** User model*/public function favorites()&#123; //第二个参数为关系表名，如果不传默认找article_user表 $thie-&gt;belongsToMany(Article::class, 'favorites')-&gt;withTimestamps();&#125; 3、展示内容（可以在 Route 完成，也可以在 Controller 中完成）12345678910Route::get('/article', function()&#123; $articles = Article::latest(); if(Auth::check()) &#123; $favorites = Favorites::where('user_id', Auth::user()-&gt;id) -&gt;lists('article_id')-&gt;toArray(); &#125; return view('index', compact('articles', 'favorites'));&#125;); 4、在视图文件创建收藏模块1234567891011121314@if(Auth::check()) @if(in_array($article_id, $favorites)) &lt;!--取消收藏--&gt; &#123;!! Form::open(['url' =&gt; '/path2']) !!&#125; &#123;!! Form::hidden('article_id', $article-&gt;id) !!&#125; @else &lt;!--收藏--&gt; &#123;!! Form::open(['url' =&gt; '/path1']) !!&#125; &#123;!! Form::hidden('article_id', $article-&gt;id) !!&#125; @endif &lt;button type="submit"&gt;&lt;i class="fa fa-heart &#123;&#123; in_array($article-&gt;id, $favorites? 'favorited' : 'not-favorited') &#125;&#125;"&gt;&lt;/i&gt;&lt;/button&gt; &#123;!! Form::close() !!&#125;@endif &lt;!--展示内容--&gt; 增加css123456.favorited, not-favorited:hover&#123; color: red;&#125;.not-favorited, .favorited:hover&#123; color: #000;&#125; 5、完成 收藏内容 和 取消收藏 内容方法以及 登录保护12345678910111213141516171819202122/*** Controller*/public function __construct()&#123; $this-&gt;middleware('auth'); //只有用户登录才可以完成收藏和取消收藏&#125;public function store(Request $request)&#123; Auth::user()-&gt;favorites()-&gt;attach($request-&gt;get('article_id')); return redirect()-&gt;back();&#125;public function cancel_store(Request $request)&#123; Auth::user()-&gt;favorites()-&gt;detach($request-&gt;get('article_id')); return redirect()-&gt;back();&#125; 对上传图片进行裁剪 引用intervention image1、安装1$ php composer.phar require intervention/image 2、配置在 config\app.php 中的 provider 数组中加入1Intervention\Image\ImageServiceProvider::class 在 config\app.php 中的 aliases 数组中加入1'Image' =&gt; Intervention\Image\Facades\Image::class 3、生成配置1$ php artisan vendor:publish --provider="Intervention\Image\ImageServiceProviderLaravel5" 4、使用1234/*** 此操作会将指定的图片 resize 后覆盖原图*/$img = Image::make('./upload/images/name.jpg')-&gt;resize(200, 300)-&gt;save('./upload/images/name.jpg');]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>project</tag>
        <tag>mixture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 用户注册登录相关]]></title>
    <url>%2F2017%2F06%2F11%2Flaravel-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[laravel实现用户注册和登录以及用户信息相关 实现密码自动加密 在 user 表中使用 attribute1234public function setPasswordAttribute($password)&#123; $this-&gt;attributes['password'] = Hash::make($password);&#125; 登录 12345678/*** controller文件*/if(Auth::attempt([ 'email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password'), //在model中定义了Attribute用Hash加密，所以不用在此不用加密 'is_confirmed' =&gt; 1])) 登出 12Auth::logout();JWToken::refresh(); 提示登录错误信息 12345678910111213/*** Controller文件*/Session::flash('id', '错误信息');/*** blade文件*/@if(Session::has('id'))&lt;div class="alert alert-danger" role="alert"&gt; &#123;&#123; Session::get('id') &#125;&#125;&lt;/div&gt;@endif 信息错误后将用户填写的信息返回给原来的页面 1return redirect('/user/login')-&gt;withInput(); 修改错误提示 打开 resources\lang\en\validation.php 修改 custom 数组123456//以下为当name为id的字段为空时提示“用户名不能为空”'custom' =&gt; [ 'name' =&gt; [ 'required' =&gt; '用户名不能为空' ]] 登录后blade显示用户信息 12345@if(Auth::check()) &#123;&#123; Auth::user()-&gt;name &#125;&#125;@else ...@endif 传统修改头像 1、引用 intervention/image packagehttps://github.com/Intervention/image1composer require intervention/image 2、修改 config\app.php 文件1234567891011121314/*** $providers数组*/Intervention\Image\ImageServiceProvider::class/*** $aliases数组*/'Image' =&gt; Intervention\Image\Facades\Image::class/*** 生成文件*/php artisan vendor:publish --provider="Intervention\Image\ImageServiceProviderLaravel5" 3、表单1234&#123;!! Form::open(['url' =&gt; '/avatar', 'files'=&gt;true]) !!&#125;&#123;!! Form::file('avatar') !!&#125;&#123;!! Form::submit('上传头像', ['class' =&gt; 'btn btn-primary pull-right'])!!&#125;&#123;!! Form::close() !!&#125; 4、修改 controller123456789101112131415use Image; //引用上面引入的packagepublic function changeAvatar(Request $request)&#123; $file = $requet-&gt;file('avatar'); $path = 'uploads/'; //在public目录下创建一个uploads目录 $filename = time().$file-&gt;getClientOriginalName(); $file-&gt;move($path, $filename); Image::make($path.$filename)-&gt;fit(200)-&gt;save(); //将图片修改为200 x 200大小的图片 $user = User::find(Auth::user()-&gt;id); $user-&gt;avatar = '/'.$path.$filename; $user-&gt;save(); return redirect('path');&#125; 5、给目录权限1chmod -R 777 uploads/ 用 Ajax 完成修改头像 实现上传头像过程按钮变化并在上传后自动更换头像 1、在 app.blade.php 中引入文件，将文件放到 public\js 中https://github.com/JellyBool/laravel-app123&lt;script src="/js/jquery-2.1.4.min.js"&gt;&lt;/script&gt;&lt;script src="/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;script src="/js/jquery.form.js"&gt;&lt;/script&gt; 2、修改头像的 blade 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="text-center"&gt; &lt;div id="validation-errors"&gt;&lt;/div&gt; &lt;img src="&#123;&#123;Auth::user()-&gt;avatar&#125;&#125;" width="120" class="img-circle" id="user-avatar" alt=""&gt; &#123;!! Form::open(['url'=&gt;'/avatar','files'=&gt;true,'id'=&gt;'avatar']) !!&#125; &lt;div class="text-center"&gt; &lt;button type="button" class="btn btn-success avatar-button" id="upload-avatar"&gt;上传新的头像&lt;/button&gt; &lt;/div&gt; &#123;!! Form::file('avatar',['class'=&gt;'avatar','id'=&gt;'image']) !!&#125; &#123;!! Form::close() !!&#125; &lt;div class="span5"&gt; &lt;div id="output" style="display:none"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;$(document).ready(function() &#123; var options = &#123; beforeSubmit: showRequest, success: showResponse, dataType: 'json' &#125;; $('#image').on('change', function()&#123; $('#upload-avatar').html('正在上传...'); $('#upload').ajaxForm(options).submit(); &#125;); &#125;); function showRequest() &#123; $("#validation-errors").hide().empty(); $("#output").css('display','none'); return true; &#125; function showResponse(response) &#123; if(response.success == false) &#123; var responseErrors = response.errors; $.each(responseErrors, function(index, value) &#123; if (value.length != 0) &#123; $("#validation-errors").append('&lt;div class="alert alert-error"&gt;&lt;strong&gt;'+ value +'&lt;/strong&gt;&lt;div&gt;'); &#125; &#125;); $("#validation-errors").show(); &#125; else &#123; $('#user-avatar').attr('src',response.avatar); &#125; &#125; 3、修改 controller 文件12345678910111213141516171819202122232425262728293031323334use Image; //引用上面引入的packageuse Illuminate\Support\Facades\Response;use Validator;public function changeAvatar(Request $request)&#123; $file = $requet-&gt;file('avatar'); $input = array('image' =&gt; $file); $rules = array( 'image' =&gt; 'image' ); $validator = Validator::make($input, $rules); if ( $validator-&gt;fails() ) &#123; return Response::json([ 'success' =&gt; false, 'errors' =&gt; $validator-&gt;getMessageBag()-&gt;toArray() ]); &#125; $path = 'uploads/'; //在public目录下创建一个uploads目录 $filename = time().$file-&gt;getClientOriginalName(); $file-&gt;move($path, $filename); Image::make($path.$filename)-&gt;fit(200)-&gt;save(); //将图片修改为200 x 200大小的图片 $user = User::find(Auth::user()-&gt;id); $user-&gt;avatar = '/'.$path.$filename; $user-&gt;save(); return Response::json([ 'success' =&gt; true, 'avatar' =&gt; asset($path.$filename), ]);&#125; 实现上传头像的裁剪 1、引入 Jcrop 文件（\public\css\jquery.Jcrop.css 和 \public\js\jquery.Jcrop.min.js）https://github.com/JellyBool/laravel-app12&lt;link rel="stylesheet" href="/css/jquery.Jcrop.css"&gt;&lt;script src="/js/jquery.Jcrop.min.js"&gt;&lt;/script&gt; 2、在 blade 中引入一个bootstrap的 model（注意创建路由指向方法为cropAvatar）12345678910111213141516171819202122232425262728293031&lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &#123;!! Form::open( [ 'url' =&gt; ['/crop/api'], 'method' =&gt; 'POST', 'onsubmit'=&gt;'return checkCoords();','files' =&gt; true ] ) !!&#125; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true" style="color: #ffffff"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;裁剪头像&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="content"&gt; &lt;div class="crop-image-wrapper"&gt; &lt;img src="/images/default-avatar.png" class="ui centered image" id="cropbox" &gt; &lt;input type="hidden" id="photo" name="photo" /&gt; &lt;input type="hidden" id="x" name="x" /&gt; &lt;input type="hidden" id="y" name="y" /&gt; &lt;input type="hidden" id="w" name="w" /&gt; &lt;input type="hidden" id="h" name="h" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button type="submit" class="btn btn-primary"&gt;裁剪头像&lt;/button&gt; &lt;/div&gt; &#123;!! Form::close() !!&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3、实现 controller 中的函数1234567891011121314151617181920212223242526272829303132333435/*** 为了实现裁剪后才将图片保存，去掉传统头像上传的 *`changeAvatar`* 方法中的三行* 修改 Response::json*/$user = User::find(Auth::user()-&gt;id);$user-&gt;avatar = '/'.$path.$filename;$user-&gt;save();return Response::json([ 'success' =&gt; true, 'avatar' =&gt; asset($path.$filename), 'image' =&gt; $path.$filename //让js中的photo变量为图片路径 ]);/*** 增加 cropAvatar函数*/public fuction cropAvatar(Request $request)&#123; $photo = $request-&gt;get('photo'); //在js文件中photo变量已经设为图片路径 $width = (int) $request-&gt;get('w'); $heigth = (int) $request-&gt;get('h'); $xAlign = (int) $request-&gt;get('x'); $yAlign = (int) $request-&gt;get('y'); Image::make($photo)-&gt;crop($width, $height, $xAlign, $yAlign)-&gt;save(); $user = Auth::user(); //给 blade &lt;img src&gt; 处理路径最前面要带上斜杠，所以要使用asset方法，用http方式补全 $user-&gt;avatar = asset($photo); $user-&gt;save(); return redirect('user/avatar'); //用户更换头像页面&#125; 4、修改 blade 文件（前部分代码看传统上传中的blade文件）123456789101112131415161718192021222324252627282930/*** 修改blade文件中的ShowResponse方法，将else部分换为以下部分，并加入两个函数*/else&#123; var cropBox = $("#cropbox"); cropBox.attr('src',response.avatar); $('#photo').val(response.image); //让blade提交表单时候photo变量为图片路径 $('#upload-avatar').html('更换新头像'); $('#exampleModal').modal('show'); cropBox.Jcrop(&#123; aspectRatio: 1, onSelect: updateCoords, setSelect: [120,120,10,10] &#125;); $('.jcrop-holder img').attr('src',response.avatar);&#125;function updateCoords(c)&#123; $('#x').val(c.x); $('#y').val(c.y); $('#w').val(c.w); $('#h').val(c.h);&#125;function checkCoords()&#123; if (parseInt($('#w').val())) return true; alert('请选择图片.'); return false;&#125; 实现第三方登录 https://github.com/overtrue/socialite 示例github1、到github注册一个Application setting -&gt; Applications -&gt; Register new application2、填写信息：callback url为请求成功后跳转的地址3、引用package1$ composer require "overtrue/socialite:~1.0" 4、注册路由12Route::get('/login', 'LoginController@github'); //认证Route::get('/github/login', 'LoginController@githubLogin'); //获取信息 5、完成认证和获取信息方法123456789101112131415161718192021222324252627282930313233/*** Controller*/protected $config = [ 'github' =&gt; [ 'client_id' =&gt; 'your-app-id', 'client_secret' =&gt; 'your-app-secret', 'redirect' =&gt; 'github注册的callback url', ],];public function github()&#123; /** * 该方法检查client_id和client_secret是否一致 * 一致就返回授权用户的信息给callback url */ $socialite = new SocialiteManager($this-&gt;config); return $socialite-&gt;driver('github')-&gt;redirect(); //跳转到github验证页面&#125;public function githubLogin()&#123; $socialite = new SocialiteManager($this-&gt;config); $githubUser = $socialite-&gt;driver('gtihub')-&gt;user(); /** * $githubUser为授权用户的信息 * $githubUser-&gt;getId(); * $githubUser-&gt;getNickname(); * $githubUser-&gt;getName(); * $githubUser-&gt;getEmail(); */&#125; 实现用户名或邮箱登录 12345678910111213141516public function login(Request $request)&#123; // 1、login为要验证的表单id // 2、验证是邮箱还是用户名 $option = filter_var($request-&gt;get('login'), FILTER_VALIDATE_EMAIL) ? 'email':'name'; $request-&gt;merge([$option =&gt; $request-&gt;get('login')]); if(Auth::attempt($request-&gt;only($option, 'password'))) &#123; //验证通过后的代码... return ...; &#125; //验证不通过的处理 ...;&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>user</tag>
        <tag>register</tag>
        <tag>login</tag>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel Request常用规则]]></title>
    <url>%2F2017%2F06%2F11%2Flaravel-Request%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[&#39;name&#39; =&gt; &#39;required|min:3&#39;&#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39; 规定 users 表的 email 字段必须为唯一password =&gt; &#39;required|min:6|confirmed&#39;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 表的联系]]></title>
    <url>%2F2017%2F06%2F11%2Flaravel-%E8%A1%A8%E7%9A%84%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[设置laravel 数据表之间的联系 1、创建一个跟用户联系的表，用 user_id ， last_user_id 作为外键123456789101112131415161718192021/*** Comment表*/$table -&gt; increments('id');$table -&gt; string('title');$table -&gt; text('body');$table -&gt; integer('user_id')-&gt;unsigned();$table -&gt; integer('last_user_id')-&gt;unsigned();$table -&gt; foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade'); //规定user_id为users表id字段的连接$table -&gt; timestamps();/*** users表*/$table -&gt; increments('id');$table -&gt; string('name');$table -&gt; string('avatar'); //用户头像url$table -&gt; string('email')-&gt;unique();$table -&gt; string('password', 60);$table -&gt; remremberToken();$table -&gt; timestamps(); 2、创建 users 表测试数据123456789101112131415$factory-&gt;define(App\User::class, function (Faker\Generator $faker) &#123; static $password; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, 'avatar' =&gt; $faker-&gt;imageUrl(256, 256), 'password' =&gt; $password ?: $password = bcrypt('secret'), 'remember_token' =&gt; str_random(10), ];&#125;);php artisan tinkernamespace App;factory(user::class, 30)-&gt;create(); 3、创建 comments 表测试数据1234567891011121314$factory-&gt;define(App\comment::class, function (Faker\Generator $faker) &#123; $user_ids = \App\User::pluck('id')-&gt;toArray(); //将users表中的id拿出来作为数组 return [ 'title' =&gt; $faker-&gt;sentence, 'body' =&gt; $faker-&gt;paragraph, 'user_id' =&gt; $faker-&gt;randomElement($user_ids), 'last_user_id' =&gt; ($faker-&gt;randomElement($user_ids))[0], ];&#125;);php artisan tinkernamespace App;factory(comment::class, 30)-&gt;create(); 在model中建立关系 1、修改 users 表model文件，使用Eloquent Relationship1234public function comments()&#123; return $this-&gt;hasMany(comment::class); //使用$user-&gt;comments()获取用户所有评论&#125; 2、修改 comment 表model文件，使用Eloquent Relationship12345public function user()&#123; //默认外键为user_id，如果有自定义外键作为第二个参数传入 return $this-&gt;belongsTo(User::class); //使用$comment-&gt;user()获取评论的用户&#125; 多对多关系 belongsToMany()第二个参数为两个表关系的表名，如果没有三四个参数，关系表的两个字段为model1_id, model2_id（小写），model1为belongsToMany所在的model 1、创建第三方关联表1234567891011$table-&gt;integer('article_id')-&gt;unsigned();$table-&gt;integer('tag_id')-&gt;unsigned();$table-&gt;foreign('article_id') -&gt;references('id') -&gt;on('articless') -&gt;onDelete('cascade');$table-&gt;foreign('tag_id') -&gt;references('id') -&gt;on('tags') -&gt;onDelete('cascade'); 2、在 model 文件中声明多对多关系123456789101112131415/*** Article*/public function tags()&#123; return $this-&gt;belongsToMany(Tag::class);&#125;/*** Tag*/public function articles()&#123; return $this-&gt;belongsToMany(Article::class);&#125; 3、建立关系123456789101112/*** 比如在Controller中* 以下操作都会在第三方表中自动生成数据*///将 articles 表 id 为3的与 tags 表 id 为2的绑定$article = App\Article::find(3);$article-&gt;tags()-&gt;attach(2);//将 articles 表 id 为3的与 tags 表 id 为2的解除绑定$article = App\Article::find(3);$article-&gt;tags()-&gt;detach(2);]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>database</tag>
        <tag>table</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 用户确认邮箱]]></title>
    <url>%2F2017%2F06%2F10%2Flaravel-%E7%94%A8%E6%88%B7%E7%A1%AE%E8%AE%A4%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[用laravel完成用户确认邮箱完成认证 1、在 composer.json 中加入以下内容并执行 composer update1234"require": &#123; ... , "guzzlehttp/guzzle": "~5.3|~6.0",&#125; 2、用 MandDrill driver来发送邮件，在mandrill注册后拿到 secret_key（也可以用sendcloud）3、配置 .env 文件12MAIL_DRIVER=mandrillMANDRILL_SECRET=拿到的secret key 4、配置 mail.php1'from' =&gt; ['address' =&gt; '发送email的邮箱', 'name' =&gt; '名字'] 5、在 migration 文件中给表增加两个字段，并在 model 文件中将字段加入 $fillable 数组中1234567891011/*** migration文件*/$table-&gt;string('confirm_code', 64);$table-&gt;integer('is_confirmed')-&gt;default(0); //0代表没激活，1代表已激活/*** model文件*/protected $fillable = [... , 'confirm_code']; 6、用 ModelFactory 添加测试信息（测试用，可跳过）1234567891011/*** 在ModelFactory文件中加入*/'confirm_code' =&gt; str_random(48),/*** 用php artisan tinker生成数据*/php artisan tinkernamespace App;factory(modelName::class, 30)-&gt;create(); 7、编写 Controller 文件123456789101112131415161718192021public function store(yourRequest $request)&#123; $data = [ 'confirm_code' =&gt; str_random(48), ] $user = modelName::create(array_merge($request-&gt;all(), $data)); $subject = '内容'; $view = 'email.register'; //传views\email\register.blade.php $this-&gt;sendTo($user, $subject, $view, $data); //在后面生成sendTo方法 return redirect('/');&#125;private function sendTo($user, $subject, $view, $data = [])&#123; Mail::queue($view, $data, function($message) use ($user, $subject)&#123; $message-&gt;to($user-&gt;email)-&gt;subject($subject); //$user-&gt;email为用户注册填写的email &#125;);&#125; 8、编写 Controller ：文件当用户点击链接时的处理函数123456789101112131415public function confirmEmail($confirm_code)&#123; $user = User::where('confirm_code', $confirm_code)-&gt;first(); if(is_null($user)) &#123; return redirect('/'); &#125; //如果有查找到用户将认证设置为1，并再生成一个confirm_code确保下次点击url时无效 $user-&gt;is_confirmed = 1; $user-&gt;confirm_code = str_random(48); $user-&gt;save(); return redirect('user/login');&#125; 9、生成发送给用户的url 和 设置路由123456789/*** 在视图中生成url*/&lt;a href="&#123;&#123; url('verify/'. $confirm_code) &#125;&#125;"&gt;Click To Confirm&lt;/a&gt; //sendTo函数包含$confirm_code参数/*** 生成路由*/Route::get('verify/&#123;confirm_code&#125;', 'nameController@confirmEmail'); 重构邮件发送类(用event)并集成 SendCloud 邮件服务 一、重构邮件发送类1、在 model 中定义方法取代 modelName::create()1234567public static function register(array $array) //array为用户数据构成的数组&#123; $user = static::create($array); event(new EventName($user)); //触发事件完成listener中handle方法内容 return $user;&#125; 2、在 event 文件中修改 __construct 方法123456public $user;public function __construct(User $user)&#123; $this-&gt;user = $user;&#125; 3、修改 listener 文件1234567891011121314class SendWelcomeEmail&#123; public $mailer; public function __construct(UserMailer $mailer) &#123; $this-&gt;mailer = $mailer; &#125; public function handle(EventName $event) &#123; $this-&gt;mailer-&gt;welcome($event-&gt;user); &#125;&#125; 4、在 App 下创建 Mailer\Mailer.php （注意namespace是 App\Mailer ）123456public function sendTo($user, $subject, $view, $data=[])&#123; Mail::queue($view, $data, function($message) use ($user, $subject)&#123; $message-&gt;to($user-&gt;email)-&gt;subject($subject); &#125;);&#125; 5、因为所有邮件发送都会调用到源生的 Mail，所以将 Mailer 作为父类继承：创建一个 Mailer\UserMailer（namespace为 App\UserMailer）1234567891011class UserMailer extends Mailer&#123; public function welcome($user) &#123; $subject = "Welcome to xxx"; $view = "emails.welcome"; //创建views\emails\welcome.blade.php $data = ['name' =&gt; $user-&gt;name, 'toekn' =&gt; $user-&gt;token]; //token为confirmed_code $this -&gt; sendTo($user, $subject, $view, $data); &#125;&#125; 集成 SendCloud 服务1、配置 mail.php1'from' =&gt; ['address' =&gt; '发送email的邮箱', 'name' =&gt; '名字'] 2、配置 .env12SENDCLOUD_API_USER= SendCloud 上的 API_USERSENDCLOUD_API_KEY= SendCloud 上的 API_KEY 3、修改 Mailer\Mailer.php1234567891011121314151617181920212223242526protected $url = 'http://api.sendcloud.net/apiv2/mail/sendtemplate'; //一定要加这一行public function sendTo($user, $subject, $view, $data=[])&#123; $vars = json_encode(['to' =&gt; [$user-&gt;email], 'sub' =&gt; $data]); $param = [ 'apiUser' =&gt; env('SENDCLOUD_API_USER'), # 使用api_user和api_key进行验证 'apiKey' =&gt; env('SENDCLOUD_API_KEY'), 'from' =&gt; config('mail')['from']['address'], # 发信人，用正确邮件地址替代 'fromName' =&gt; config('mail')['from']['name'], 'xsmtpapi' =&gt; $vars, 'subject' =&gt; $subject, 'templateInvokeName' =&gt; $view, 'respEmailId' =&gt; 'true' ]; $sendData = http_build_query($param); $options = [ 'http' =&gt; [ 'method' =&gt; 'POST', 'header' =&gt; 'Content-Type: application/x-www-form-urlencoded', 'content' =&gt; $sendData ]]; $context = stream_context_create($options); return file_get_contents($this-&gt;url, FILE_TEXT, $context);&#125; 4、修改 Mailer\UserMailer.php1234567public function welcome($user)&#123; $subject = '邮箱确认'; //必须跟SendCloud上的邮件标题一样 $view = 'welcome'; //必须跟SendCloud上的调用名称一样 $data = ['%name%' =&gt; [$user-&gt;name],'%token%' =&gt; [str_random(40)]]; //SendCloud将%var%作为参数 $this-&gt;sendTo($user, $subject, $view, $data);&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>mail</tag>
        <tag>SendCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP单元测试]]></title>
    <url>%2F2017%2F06%2F09%2FPHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[与php单元测试相关内容 laravel下创建一个简单的单元测试 1、在 tests\Unit 目录下创建一个如 NameTest 的文件2、让类继承于 phpUnit 类，引用被测试的类12345678910111213141516/*** 用于用于测试App\Product.php中的Product类中的name()方法是否返回'Mac'*/use App\ClassName;class NameTest extends \PHPUnit_Framework_TestCase&#123; /** @test */ //一定要声明为test，并且按照此行格式写 public function a_product_has_a_name () //声明函数名用`_`分开 &#123; $product = new Product('Mac'); $this-&gt;assertEquals('Mac', $product-&gt;name()); &#125;&#125; 3、运行测试 vendor/bin/phpunit 或 phpunit，如果只运行单个测试文件1phpunit --filter=NameTest 4、解决单元测试代码重用问题：加入 setUp 函数（在每个函数执行之前都会先执行 setUp 函数内的内容）1234public function setUp()&#123; ...;&#125; Laravel测试Eloquent Model 1、在 tests/Unit 下创建文件，并继承laravel的测试类TestCase1234567891011121314151617use Illuminate\Foundation\Testing\DatabaseTransactions;class NameTest extends TestCase&#123; use DatabaseTransactions; //防止每次测试都产生数据 public function test_method() &#123; factory(Article::class, 3)-&gt;create(); //先在ModelFactory加入生成数据代码 factory(Article::class)-&gt;create(['reads' =&gt; 10]); //增加一条信息，read字段为10 $mostPopular = factory(Article::class)-&gt;create(['reads' =&gt; '20']); $articles = Article::trending(); //该方法按reads大小降序排列文章 $this-&gt;assertEquals($mostPopular-&gt;id, $articles-&gt;first()-&gt;id); &#125;&#125; 2、在 model 中编写相应方法（用到 queryScope ）1234public function scopeTrending($query)&#123; return $query-&gt;orderBy('reads', 'desc')-&gt;get();&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phpunit</tag>
        <tag>test</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php命名空间和自动加载]]></title>
    <url>%2F2017%2F06%2F08%2Fphp%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[解决包含 Class 要用多个 require 问题 1、在项目目录下创建 composer.json 文件，加入以下内容1234567&#123; "autoload":&#123; "psr-4":&#123; "namespace的名\\":"实际路径名/" &#125; &#125;&#125; 2、在要被加载的文件加入1namespace namespace的名; 3、生成 autoload 文件并加载1composer dump-autoload 4、在加载其他文件的文件中加入123require 'vendor/autoload.php';use namespace的名\Class文件名;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>namespace</tag>
        <tag>require</tag>
        <tag>autoload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用操作]]></title>
    <url>%2F2017%2F06%2F07%2Fvim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[插入 在当前位置前插入：i在当前行首插入：I在当前位置后插入：a在当前行尾插入：A在当前行之后插入一行：o在当前行之前插入一行：O 跳转 跳到到行尾：$跳到到行首：0跳到n行：nG跳到文本末尾：G向下翻页：Control + f向上翻页：Control + b下一个单词：w上一个单词：b下一行行首：+上一行行首：- 删除 删除到行首：d$删除到行尾：D删除光标字符：x删除光标后的单词：de 复制粘贴 复制当前行：yy复制从光标到行尾的内容：y$复制从光标到行首的内容：y^粘贴到光标右侧：p粘贴到光标左侧：P 查找 查找：/content（ n 跳到下一个内容 ）]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Model Factory]]></title>
    <url>%2F2017%2F06%2F06%2FModel-Factory%2F</url>
    <content type="text"><![CDATA[运用 Model Factory 本地化并且创建数据库数据 可生成的字段：https://github.com/fzaninotto/Faker 一、用tinker生成 1、在 database\factories 中创建或使用文件，根据上述网址添加字段2、本地化（使用中文创建数据）：修改 App\Providers\AppServiceProvider.php 的 boot 方法123456789101112use Faker\Generator as FakerGenerator;use Faker\Factory as FakerFacotry;...public function boot() &#123; //singleton方法：启动laravel项目的时候，该方法将写在里面的类返回单例模式给Laravel全局使用 $this-&gt;app-&gt;singleton(FakerGenerator::class, Function() &#123; return FakerFacotry::create('zh_CN'); &#125;);&#125; 3、使用12345php artisan tinker //进入tinkernamespace App;factory(ModelName::class, num)-&gt;make() //num为要生成的数据个数，make方法只生成数据不加入数据库factory(ModelName::class, num)-&gt;create() //num为要生成的数据个数，create方法将生成的数据加入数据库 4、根据另一个表的 id 生成随机 id1234567$factory-&gt;define(App\Post::class, function (Faker\Generator $faker) &#123; $user_ids = App\User::pluck('id')-&gt;toArray(); return [ 'content' =&gt; $faker-&gt;sentence, 'user_id' =&gt; $faker-&gt;randomElement($user_ids), ];&#125;); 二、用DB Seed生成 1、生成 seeder 文件1php artisan make:seeder FileName 2、改 database\seeds\FileName 中的 run 方法1234public function run()&#123; factory(\App\ModelName::class, num)-&gt;create(); //num为要创建的数据条数&#125; 3、因为执行 php artisan db:seed 默认执行 DatabaseSeeder 文件，故要在该文件加入以下内容1$this-&gt;call(FileName::class); 4、执行php artisan db:seed 如果要生成一个另一个表的数据1、在ModelFactory中增加1234567891011121314$factory-&gt;define(App\ModelName::class, function (Faker\Generator $faker) &#123; static $password; return [ //'name' =&gt; $faker-&gt;name, //'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, //'password' =&gt; $password ?: $password = bcrypt('secret'), //'remember_token' =&gt; str_random(10), 'title' =&gt; $faker-&gt;sentence, 'intro' =&gt; $faker-&gt;paragraph, 'time' =&gt; $faker-&gt;dateTime, 'image' =&gt; $faker-&gt;imageUrl, ];&#125;); 2、在DatabaseSeeder 文件加入以下内容1$this-&gt;call(FileName::class);]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Event]]></title>
    <url>%2F2017%2F06%2F04%2FLaravel-Event%2F</url>
    <content type="text"><![CDATA[当触发某个事件时自动完成一系列的操作 1、如果要修改新 Event 的名称，修改 EventProvider.php 中的 listen 数组12345678910111213protected $listen = [ 'App\Events\NewEventName1' =&gt; [ 'App\Listeners1\ListenersName1', 'App\Listeners1\ListenersName2', ... ], 'App\Events\NewEventName2' =&gt; [ 'App\Listeners2\ListenersName1', 'App\Listeners2\ListenersName2', ... ], ...]; 2、到 listener 监听文件中的 handle 函数编写当事件触发时要执行的操作1234public function handle(EventName $event)&#123; ...&#125; 3、触发事件1event(new \App\Events\EventName()); 引用功能模块 1、引入模块功能，修改 __construct() 函数1234567class ListenerName&#123; public function __construct(Filesystem $filesystem) &#123; $this-&gt;filesystem = $filesystem; &#125;&#125; 2、编写处理操作，修改 handle 函数1234public function handle(EventName $event)&#123; $this-&gt;filesystem-&gt;method();&#125; 示例：触发用户事件 1、更改 Event 文件中的 __construct() 函数123456789101112&lt;?php...class EventName extends Event&#123; ... public $user; public function __construct(User $user) //接收事件发生时传来的用户数据参数 &#123; $this-&gt;user = $user; &#125;&#125; 2、更改 listener 文件1234public function handle(EventName $event)&#123; $event-&gt;user-&gt;name; //由Event文件传来的数据，引用用户名&#125; 3、在 Route 触发事件12$user = \App\User::find(1); event(new \App\Events\EventName($user)); //在Event文件编写了__construct()，所以传用户数据进去能进行以后操作 用event优化用户注册 1、在 model 中定义方法取代 modelName::create()1234567public static function register(array $array) //array为用户数据构成的数组&#123; $user = static::create($array); event(new EventName($user)); //触发事件完成listener中handle方法内容 return $user;&#125; 2、在 event 文件中修改 __construct 方法123456public $user;public function __construct(User $user)&#123; $this-&gt;user = $user;&#125; 3、在 listener 文件中修改 handle 方法1234public function handle(EventName $event)&#123; return $event-&gt;user-&gt;email;&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 向 Container 添加自定义类]]></title>
    <url>%2F2017%2F06%2F03%2FLaravel-%E5%90%91-Container-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1、通过 php artisan make:provider ProviderName 创建一个 provider 2、在 app 创建一个新的目录，目录创建新的类文件123456789&lt;?phpnamespace App\directoryNameclass className &#123; public function fname () &#123; ...; &#125;&#125; 3、在新建的 provider 中的 register 函数绑定全局自己自定义的类123456public function register ()&#123; $this-&gt;app-&gt;bind('name', function() &#123; return new ClassName(); &#125;);&#125; 4、（放入IOC中，可以在任何地方使用 app(&#39;name&#39;)实现 3 中的类）在 config\app.php 的 provider 数组中增加新建的 provider1234'providers' =&gt; [ ... App\Providers\NewServiceProvider::class; //NewServiceProvider为新建的provider文件名] 5、在 laravel 的 任何地方可以调用类已经类里面的方法（app 内的参数名必须是在新 provider 的 register 函数中绑定的通过 app 绑定的名字）12345//在web.php中调用Route::get('/', function () &#123; $var = app('name'); //实例化了一个ClassName对象 $var-&gt;fname();&#125;)]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http状态码]]></title>
    <url>%2F2017%2F06%2F01%2FHttp%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Http常用状态码 2**：成功处理请求的状态代码 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3**：要完成请求，需要进一步操作 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4**：请求错误 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5**：服务器错误 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>project</tag>
        <tag>status code</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F30%2FPhpStorm%2F</url>
    <content type="text"><![CDATA[title: PhpStormdate: 2017-05-30 21:32:47tags: ide PhpStormcategories: phpstorm PhpStorm快捷键等 一、通用类1、*Command + Shift + A：搜索配置项（搜索keymap改快捷键）2、Command + P：文件之间跳转3、Command + B：查看类的关系4、Command + Control + S：查看类里面的方法等 二、编辑类1、Command + Delete：删除光标行2、Shift + Delete：删除光标后面所有内容3、Control + Delete：删除光标前面所有内容4、Control + Shift + Delete：删除光标所在单词5、Command + Shift+ D：复制当前行到下一行6、Command + D：逐个选相同的词（多点编辑）7、Command + Control + D：全选相同的词（多点编辑）8、Command + G：选中下一个光标所在一样的词9、Command + Shift + G：选中上一个光标所在一样的词]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序相关文档]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[与小程序相关网站 文档类 微信小程序官方文档：https://mp.weixin.qq.com/debug/wxadoc/dev/&lt;简书&gt;小程序开发专栏：http://www.jianshu.com/c/dfdc2bbd1315W3Cschool文档：http://www.w3cschool.cn/weixinapp/weixinapp-app.html 各功能实现 功能合集：http://weixin1024.cn/forum.php?mod=viewthread&amp;tid=1027&amp;extra=page%3D1 小程序账号申请 &lt;有道云笔记&gt;：http://note.youdao.com/share/?id=744b94b02c28321c8f930e1f495624e5&amp;type=note#/ 项目案例 项目列表：http://blog.csdn.net/qq137722697/article/details/52988719小黄车小程序：http://www.jianshu.com/p/68e3b8927a77项目：http://www.cnblogs.com/tuyile006/p/6268961.html 登录注册实现 维护用户登录态可以用JWT完成1、注意设置JWT过去时间123456$payload = [ 'email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password')， 'exp' =&gt; time()+60*60 //设置token过期时间 ];$token = JWTAuth::attempt($payload) &lt;简书&gt;后台登录文章：http://www.jianshu.com/p/6096e8522c4c注册登录实现：http://blog.csdn.net/qq_19558705/article/details/65935818?utm_source=gold_browser_extension http站点转https站点 在nginx服务器下配置和安装阿里云购买的SSL证书：http://sanwen.net/a/hmdfcoo.html request请求(前端后台数据交互) request请求：http://blog.csdn.net/qq_19558705/article/details/60783448]]></content>
      <categories>
        <category>Wechat</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
        <tag>Mini Programes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 面向对象编程]]></title>
    <url>%2F2017%2F05%2F14%2FPHP-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PHP 面向对象相关 final关键字 final关键字只能用来标记类和方法1、final标记的类不能被继承2、final标记的方法不能被子类覆盖，是最终版本 __call()方法 当调用对象内部方法不存在时自动调用，第一个参数为不存在的函数名，第二个参数把这个方法里的参数作为数组形式传进来1234567891011121314class test &#123; function __call($function_name, $args) &#123; echo $function_name; print_r($args); &#125;&#125;$test = new test();$test -&gt; hello('you', 'are', 'sb');//程序不会退出继续执行echo "11111"; 上述的输出结果为hello Array([0] =&gt; you [1] =&gt; are [2] =&gt; sb) static 和 const 1、static（1）static的成员在类第一次被加载的时候分配空间，被实例化的对象共用，属于类，无法用$this访问（2）在类内部访问static成员1self::$变量名 //有'$' （3）在类外部访问static成员1ClassName::$变量名 //有'$' 2、const（1）const为在类内部定义常量的方法（2）在类内部访问const属性1self::变量名 //没有'$' （3）在类外部访问const属性1ClassName::变量名 //没有'$' trait 解决代码重用问题1234567891011121314151617trait NameTrait &#123; public function fun() &#123; var_dump('something'); &#125;&#125;class className1 &#123; use NameTrait;&#125;class className2 &#123; use NameTrait;&#125;new ClassName1()-&gt;fun();new ClassName2()-&gt;fun(); public、protected、private protected方法不能直接在继承的类的对象中访问，要在继承类中重新定义一个方法里面调用 $this-&gt;method1、public声明的成员可以在任何位置调用2、protected声明的成员只有在类的内部还有子类中可以调用3、private声明的成员只有在类的内部可以调用4、调用方法为12$this -&gt; name; //调用成员属性$this -&gt; function(); //调用成员方法 注：子类的权限只能大于等于父类 接口（Interface） 定义：类里面所有的方法都为抽象方法的类称为接口1、接口内不能声明变量，但可以声明常量constant2、所有成员都是public权限3、声明接口使用关键字interface123456789101112&lt;?phpinterface One &#123; //定义一个常量 const constant = 'constant value'; //定义一个抽象方法"fun1" public function fun1(); //定义了抽象方法"fun2" public function fun2();&#125;?&gt; 4、定义接口的子类实现接口中全部抽象方法使用关键字implements123456789101112&lt;?phpclass Three implements One &#123; function fun1() &#123; ... &#125; function fun2() &#123; ... &#125;&#125;&#125;?&gt; 5、子类必须实现所有的抽象方法才能被实例化6、一个类可以实现多个接口12345&lt;?phpclass Four implements interface1, interface2, ... &#123; //必须把所有接口中的方法都实现才可以实例化对象&#125;?&gt; 7、在继承一个类的同时实现多个接口，先继承再实现123456&lt;?phpclass Four extends ClassName1 implements interface1, interface2, ... &#123; //所有接口中的方法都要实现才可以实例化对象 ...&#125;?&gt; 面向接口编程 在需要用到类作为参数的方法中将接口作为参数，过后传参数只需要传一个实现的接口的对象就可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** 创建一个接口*/interface hello &#123; public function fun1($message);&#125;/*** 实现接口*/class class1 implements hello &#123; public function show($message) &#123; return $message; &#125;&#125;/*** 实现接口*/class class2 implements hello &#123; public function show($message) &#123; return $message; &#125;&#125;/*** 创建一个类*/class Controller &#123; protected $hello; //参数为接口 public function __construct(hello $hello) &#123; $this-&gt;hello = $hello; &#125; public function show() &#123; $message = "Nancelglap"; $this-&gt;hello-&gt;show($message); &#125;&#125;//当要切换类的时候就不用再更改construct方法中的hello接口，直接改实例化对象的类名$demo = new Controller(new class1);$demo -&gt; show();$demo = new Controller(new class2);$demo -&gt; show();]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关]]></title>
    <url>%2F2017%2F05%2F13%2Fgit%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[与git相关的内容 Git配置 一、增加配置项1git config --global/system 配置名 "值" 1、如果只在当前项目增加配置 （1）切换到当前项目 （2）git config 配置名 &quot;值&quot;1、--global 将配置放到home目录下（~/.gitconfig）2、--system 将配置放到/etc/.gitconfig中3、--local 将配置放到每一个项目中4、常用配置有user.name、user.eamil，color.ui，core.editor 二、查看配置项1git config 配置名 Git基本工作流程 1、查看修改状态1git status 2、初始化当前目录1git init 3、如果有文件修改，先加入 staged area1git add 文件名 / git add . 4、更新提交到 staged area 的内容（只修改没执行git add的不会更新）1git commit -m "更新描述" 5、查看 commit 的内容1git log //按q退出 .gitignore 将上传的文件内容加入此文件中，更新会忽略此文件1、用PhpStorm编辑的，加入.idea2、用Mac系统的，加入.DS_Store Git分支 想修改之前的bug，但是又不想将还没写完的新内容提交上去等 1、查看分支1$ git branch 2、回到某个文件提交之前的内容1$ git checkout -- app/Http/routes.php 3、创建分支、切换到分支1234$ git branch BranchName$ git checkout BranchName$ git checkout -b BranchName //创建分支并切换到该分支 4、合并分支（在matser下操作）1$ git merge BranchName 5、删除分支1$ git branch -d BranchName 6、推送本地分支到远程分支1$ git push origin local_branch:remote_branch 7、拉取远程分支（拉取远程 dev 分支，在本地创建 dev 分支）1$ git checkout -b dev origin/dev Git分支merge冲突的修改 当master和分支中同个文件修改存在冲突，则需要处理 必须是两个分支的文件都已经git add和git commit -m&quot;content&quot;操作1、切换到master，执行 git merge BranchName，会报有冲突 2、进入冲突文件，删掉不要的冲突内容，然后执行1234$ git add fileName$ git commit//进入到vim后保存退出 Git设置快捷键 1$ git config --global alias.s status //设置后用 git s 替代 git status 全局设置快捷键1234$ vim ~/.zshrc//加入以下内容$ alias gs="git status" //设置后用 gs 替代 git status Git stash 运用场景：如果在一个分支上开发一个模块同时，又要回到master中改bug，执行git stash可以将分支上的修改先放到一边，回到master中更新内容 12345$ git stash list //查看之前拿开的内容$ git stash apply stash@&#123;num&#125; //恢复相应num的内容$ git stash pop //回复内容并删除，省略掉drop步骤$ git stash drop //删掉list中拿开的内容` 作用：1、将在 master 中修改好的合并到未完成的分支上2、master 未融合未完成的分支的内容 过程一、修改 master 上的内容，合并到分支上，但分支内容不合并到 master 上 1、修改分支的内容 2、在分支执行 git stash 3、在 master 分支中更改内容，改完之后gaa、gc “content” 4、回到 master 分支，执行git merge BranchName 合并 二、继续完成分支上的内容，完成后合并到 master 1、git checkout BranchName切换到分支 2、git stash apply 或 git stash pop 拿回原来拿开的问题 3、继续写分支内容，写完然后 gaa、gc “content” 4、回到 master 分支，执行git merge BranchName 合并 本地更新代码后更新到github上 123$ git add .$ git commit -m "描述内容"$ git push origin master 本地更新到远程服务器上 1234567$ git add .$ git commit -m "描述内容" //只有更改文件的目录才会改描述内容$ git push//切到服务器，进入项目目录$ cd /var/www/laravel/$ git pull]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS上配置和域名解析]]></title>
    <url>%2F2017%2F05%2F13%2FVPS%E4%B8%8A%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、更改/etc/nginx/sites-avaliable/default修改server中的server_name1server_name elective.com www.elective.com; 2、重启nginx使配置文件生效1sudo service nginx restart 3、解析域名（1）复制IP地址（2）打开dnspod进行域名解析https://www.dnspod.cn/（3）将记录类型为A的记录值修改为IP地址（4）复制上方的DNS修改内容，到godaddy网站https://sg.godaddy.com/zh?isc=gennbacn29&amp;countrview=1&amp;currencytype=CNY&amp;mkwid=WFSMCUdy&amp;cvosrc=ppc.baidu（5）到mydomain里修改Nameservers，nameservers type改为Custom，两个Nameserver内容粘贴刚才复制的两条内容]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>VPS</tag>
        <tag>server</tag>
        <tag>Domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装LEMP环境]]></title>
    <url>%2F2017%2F05%2F12%2F%E5%AE%89%E8%A3%85LEMP%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在mac/linux上安装LEMP环境 购买远程服务器VPS教程：https://www.laravist.com/series/deploy-laravel-app-on-vps/episodes/1 1、先登录远程服务器1ssh root@Ip Address 查看服务器（选择ubuntu14）1lsb_release -a 2、更新apt-get1sudo apt-get update 3、安装语言包避免系统语言引起的冲突问题1sudo apt-get install -y language-pack-en-base 4、设置语言1locale-gen en_US.UTF-8 5、安装常用工具1sudo apt-get install -y vim htop git //htop查看机器cup等用了多，git用于部署项目 6、安装php7（通过添加ppa方式安装）12345678910sudo apt-get install -y software-properties-commonsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/phpsudo apt-get updateapt-cache search php7.1 //查找php7.1包sudo apt-get install -y php7.1php -v //查看版本sudo apt-get install -y php7.1-mysqlsudo apt-get install -y php7.1-fpmsudo apt-get install -y php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring 7、安装mysql1sudo apt-get install mysql-server-5.6 8、安装nginx1sudo apt-get install nginx 9、阿里云服务器用ip地址访问http://blog.csdn.net/qq_27211105/article/details/55668997增加安全组配置规则1、网卡类型：公网2、规则方向：入方向3、授权策略：允许4、协议类型：TCP5、端口范围：80/806、授权类型：地址段访问7、授权对象：0.0.0.0/08、优先级：1]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在购买的VPS上配置环境运行Laravel]]></title>
    <url>%2F2017%2F05%2F12%2F%E5%9C%A8%E8%B4%AD%E4%B9%B0%E7%9A%84VPS%E4%B8%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8CLaravel%2F</url>
    <content type="text"><![CDATA[php + nginx + mysql 购买VPS服务器地址：https://www.vultr.com/ 1、先登录远程服务器1ssh root@Ip Address 2、配置php（修改php.ini）1sudo vim /etc/php/7.1/fpm/php.ini 将cgi.fix_pathinfo=1去掉注释，并改为1cgi.fix_pathinfo=0 3、配置php-fpm（可以不改）1vim /etc/php/7.1/fpm/pool.d/www.conf （可以不改）改listen = /run/php/php7.1-fpm.sock为1listen = /var/run/php7.1-fpm.sock 4、配置nginx的default文件1vim /etc/nginx/sites-avaliable/default 改server内容1234567891011server&#123; root /var/www/laravel/public; //自定义根目录，laravel为创建的项目 index index.php index.html index.htm; //服务器首先找public目录下的index.php server_name localhost; //如果有注册域名就改为自己的域名 //修改location里面的try_files location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125;&#125; 直接增加location ~ \.php$12345678location ~ \.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass unix:/var/run/php7.1-fpm.sock; //如果php-fpm配置改了就要改成相应的listen值 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 5、创建根目录根据/etc/nginx/sites-avaliable/default中server内容中的root创建根目录1mkdir /var/www //根据自定义的路径创建 6、改根目录拥有者1sudo chown -R www-data:www-data /var/www //www-data默认为nginx的用户名和用户组 7、在服务器根目录下创建Laravel项目并上传到github 通过git拉取实现 （1）回到本地创建Laravel项目12laravel new ProjectName //如果没将laravel加入全局变量就用composercomposer create-project laravel/laravel ProjectName （2）在github创建新项目 （3）上传项目先在服务器上创建ssh key，后加入到github的ssh key中1ssh-keygen -t rsa -C “github邮箱” 12345678cd ProjectName/git initgit add .git commit -m "更改描述"git remote add origin git@github.com:UserName/ProjectName.git //UserName为自己的github用户名，ProjectName为在github创建的项目名git push -u origin master （4）刷新github就可看见代码 8、用git将github上的代码克隆到服务器开发的话如果有更新就先将代码推送到gtihub，再从服务器拉取代码123git pull //更新github上的代码//ssh登录远程服务器后，切到www目录git clone git项目地址 更新项目 本地更新到服务器上 1234567git add .git commit -m "描述内容" //只有更改文件的目录才会改描述内容git push//切到服务器，进入项目目录cd /var/www/laravel/git pull 本地更新到github上 123git add .git commit -m "描述内容"git push origin master 9、安装composer 地址www.getcomposer.org/download/ （1）全局使用composer1mv composer.phar /usr/local/bin/composer （2）进入到项目目录123cd /var/www/ProjectName/composer install --no-dev 如果composer install --no-dev出现问题，因为没安装zip、和unzip 10、创建.env文件并修改权限123cd /var/www/ProjectName/vim .env （1）加入所有配置项，修改以下(未修改的未列出)123456APP_ENV = productionAPP_DEBUG = falseDB_DATABASE = 数据库名DB_USERNAME = 数据库用户名DB_PASSWORD = 数据库用户密码 （2）修改权限1sudo chmod -R 775 storage/ 11、重载nginx，重启php-fpm，将项目目录给nginx用户123sudo service nginx reloadsudo service php7.1-fpm restartsudo chown -R www-data:www-data /var/www/ProjectName/]]></content>
      <categories>
        <category>server</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>VPS</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户认证（Auth）]]></title>
    <url>%2F2017%2F05%2F10%2F%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[一、auth.php文件配置(修改auth验证的表) 在guards数组中的每一项都是一个角色，默认的有web和api两种，这就表示了当前有这两种角色会使用到认证系统。driver就是表示这个认证要怎么去保存用户状态，一般是保存在session中，provider就是告诉Laravel你的用户信息保存在哪一张表里面，driver就是告诉了要使用那种方式来操作数据库。1234567891011'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'token', 'provider' =&gt; 'users', ],], 二、具体运用 方法一：在Controller中增加middleware键值对当路由中使用了保护路由：&#39;middleware&#39; =&gt; &#39;auth&#39;，此路由需先经过路由的路径名为’/login’执行后才跳转到此路由执行可以对路由组使用此中间件，以下组内所有路由的访问都需先经过路由路径为’/login’的认证路由中的路径必须是根目录下的’/login’1234//如果路径前面再加任何的前缀就会出错'/admin/path'Route::get('/login', function() &#123; return view('auth.login'); &#125;) 1234567Route::group(['namespace'=&gt;'Admin', 'middleware'=&gt;'auth'], function()&#123; Route::get('admin/path1', 'UploadController@method1'); Route::get('admin/path2', 'UploadController@method2'); Route::get('admin/path3', 'UploadController@method3'); Route::get('admin/path4', 'UploadController@method4');&#125; 方法二：在控制器中增加构造方法__construct1234public function __construct()&#123; $this-&gt;middleware('auth');&#125; 补充返回经过JWTAuth认证后的实例123Route::get('/user', function (Request $request) &#123; return $request-&gt;user();&#125;)-&gt;middleware('jwt.api.auth');]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>middleware</tag>
        <tag>auth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT + dingo]]></title>
    <url>%2F2017%2F05%2F10%2FJWT-dingo%2F</url>
    <content type="text"><![CDATA[laravel 中JWT(Json Web Token)和dingo的使用 dingo dingo的作用给前端提供数据接口，前后端分离，返回JSON数据 一、安装 安装方法 1修改composer.json文件，执行composer update把最后一个版本的包加入项目中123"require": &#123; "dingo/api": "1.0.*@dev"&#125; 安装方法 2在命令行执行composer require命令1composer require dingo/api:1.0.x@dev 二、配置 1、打开config/app.php，注册service provider123'provider' =&gt; [ Dingo\Api\Provider\LaravelServiceProvider::class] 2、如果想在配置文件中改变配置，使用下面Artisan命令发布配置文件1php artisan vendor:publish --provider="Dingo\Api\Provider\LaravelServiceProvider" 3、在.env中添加基础基础配置1234567API_STANDARDS_TREE = vndAPI_PREFIX = apiAPI_VERSION = v1API_DEBUG = true 三、使用 1、在routes\api.php中123456789101112$api = app('Dingo\Api\Routing\Router');$api -&gt; group(['namespace' =&gt; 'App\Api\Controllers'], function ($api) &#123; $api -&gt; get('login', 'Controllers@method'); ...; //只有在编辑信息，删除信息，创建信息的时候需要通过JWT验证客户端是否为登录的用户 $api -&gt; group(['middleware' =&gt; 'jwt.api.auth'], function ($api) &#123; $api -&gt; patch('/path/&#123;id&#125;', 'Controllers@update'); $api -&gt; post('/path/delete', 'Controllers@destory'); $api -&gt; post('/path/create', 'Controllers@store'); &#125;) &#125;) 2、创建Controller在\App\Api下创建Controller和Transformers目录在Controllers下创建BaseController.php作为被继承的基础模块1234567891011121314151617181920&lt;?php namespace App\Api\Controllers; use App\Http\Controllers\Controller; use Dingo\Api\Routing\Helpers; class BaseController extends Controller &#123; use Helpers; /**** * BaseController constructor. */ public function __construct() &#123; &#125; &#125; JWTAuth JWTAuth的作用在用户登录的时候根据要求的登录信息，token签发时间(iat)，token过期时间(exp)等进行base64编码得到的字符串叫做Payload（载荷）。之后用户的每次提交给服务器的行为都会带上token证明客户端用户身份 一、安装 安装方法 1使用Composer安装JWT扩展包：composer require tymon/jwt-auth 0.5.* 安装方法 2修改composer.json文件，执行composer update把最后一个版本的包加入项目中123"required": &#123; "tymon/jwt-auth":"0.5.*"&#125; 二、配置 1、在config/app.php中注册相应的Service Provider123'providers'=&gt;[ Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class, ] 2、注册jwt Facades1234'aliases'=&gt;[ 'JWTAuth'=&gt; Tymon\JWTAuth\Facades\JWTAuth::class, 'JWTFactory'=&gt; Tymon\JWTAuth\Facades\JWTFactory::class, ] 3、更新配置文件php artisan vendor:publish --provider=&quot;Tymon\JWTAuth\Providers\JWTAuthServiceProvider&quot; 4、生成jwt.php文件中数组的secret键成对应的值php artisan jwt:generate 关联dingo和JWT 修改config/api.php的auth12345678'auth' =&gt; [ 'basic' =&gt; function($app)&#123; return new Dingo\Api\Auth\Provider\Basic($app['auth']); &#125;, 'jwt' =&gt; function($app)&#123; return new Dingo\Api\Auth\Provider\JWT($app['Tymon\JWTAuth\JWTAuth']); &#125;], 具体运用 1、添加中间件身份验证添加一个Middleware：GetUserFromTokenphp artisan make:middleware GetUserFromToken 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\Http\Middleware;use Closure;use JWTAuth;use Tymon\JWTAuth\Exceptions\JWTException;use Tymon\JWTAuth\Exceptions\TokenExpiredException;use Tymon\JWTAuth\Exceptions\TokenInvalidException;class GetUserFromToken&#123; public function handle($request, Closure $next) &#123; $auth = JWTAuth::parseToken(); if (! $token = $auth-&gt;setRequest($request)-&gt;getToken()) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_not_provided', 'data' =&gt; '', ]); &#125; try &#123; $user = $auth-&gt;authenticate($token); &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_expired', 'data' =&gt; '', ]); &#125; catch (JWTException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_invalid', 'data' =&gt; '', ]); &#125; if (! $user) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'user_not_found', 'data' =&gt; '', ]); &#125; //$this-&gt;events-&gt;fire('tymon.jwt.valid', $user); return $next($request); &#125;&#125; 2、在/app/Http/Kernel.php中routeMiddleware新增如下内容1234protected $routeMiddleware = [ ... 'jwt.api.auth' =&gt; \App\Http\Middleware\GetUserFromToken::class, //新增注册的中间件]; 3、验证表格更改如果要修改验证的用户表名，修改config/jwt.php&#39;user&#39; =&gt; &#39;App\newName&#39;, 4、认证模块添加关注一下logout和register在AuthController中添加相应模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php namespace App\Api\Controllers; use App\Client; use Illuminate\Http\Request; use JWTAuth; use Tymon\JWTAuth\Exceptions\JWTException; use Tymon\JWTAuth\Exceptions\TokenExpiredException; use Tymon\JWTAuth\Exceptions\TokenInvalidException; class AuthController extends BaseController &#123; /** * The authentication guard that should be used. * * @var string */ public function __construct() &#123; parent::__construct(); &#125; /** * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function authenticate(Request $request) &#123; $payload = [ 'user_email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password') ]; try &#123; if (!$token = JWTAuth::attempt($payload)) &#123; return response()-&gt;json(['error' =&gt; 'token_not_provided'], 401); &#125; &#125; catch (JWTException $e) &#123; return response()-&gt;json(['error' =&gt; '不能创建token'], 500); &#125; return response()-&gt;json(compact('token')); &#125; public function logout() &#123; JWTAuth::refresh(); //刷新token，注意区别于middleware的auth $arr = array ('LOG OUT'=&gt;"SUCCESSED"); return response()-&gt;json(compact('arr')); &#125; /** * @param Request $request */ public function register(Request $request) &#123; $newUser = [ 'user_email' =&gt; $request-&gt;get('email'), 'user_name' =&gt; $request-&gt;get('name'), 'password' =&gt; bcrypt($request-&gt;get('password')) ]; $user = Client::create($newUser); $token = JWTAuth::fromUser($user); return $token; &#125; /**** * 获取用户的信息 * @return \Illuminate\Http\JsonResponse */ public function AuthenticatedUser() &#123; try &#123; if (!$user = JWTAuth::parseToken()-&gt;authenticate()) &#123; return response()-&gt;json(['user_not_found'], 404); &#125; &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json(['token_expired'], $e-&gt;getStatusCode()); &#125; catch (TokenInvalidException $e) &#123; return response()-&gt;json(['token_invalid'], $e-&gt;getStatusCode()); &#125; catch (JWTException $e) &#123; return response()-&gt;json(['token_absent'], $e-&gt;getStatusCode()); &#125; // the token is valid and we have found the user via the sub claim return response()-&gt;json(compact('user')); &#125; &#125; 5、使用Transformers隐藏返回api的数据1234567891011121314151617181920212223242526272829303132/*** app\Api\Transformers\TestsTransformer.php*/&lt;?php namespace App\Api\Transformers; /**该类为dingo api封装好**/ use League\Fractal\TransformerAbstract; class TestsTransformer extends TransformerAbstract &#123; public function transform($lesson) &#123; //访问api的时候只会返回username, email, is_free 字段 return [ 'username' =&gt; $lesson['user_name'], 'email' =&gt; $lesson['user_email'], 'is_free' =&gt; (boolean) $lesson['free'] //将 0 1 转换为false 和 true ]; &#125; &#125; /*** Controller*/public function index()&#123; $comments = Comment::all(); return $this-&gt;collection($lessons, new TestsTransformer()); //new的类为Transformer的文件名&#125; 6、在路由中指定使用jwt.api.auth[&#39;middleware&#39; =&gt; &#39;jwt.api.auth&#39;]]]></content>
      <categories>
        <category>JWT Dingo</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>JWTAuth</tag>
        <tag>dingo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本相关]]></title>
    <url>%2F2017%2F05%2F10%2FShell%E8%84%9A%E6%9C%AC%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[本文内容为bash操作相关 参数 1、echo -e：包含转义序列的字符串形式输出2、echo -n：echo会将一个换行符追加到输出文本的尾部，可以使用-n忽略结尾换行符 其他 1、要输出感叹号的时候不要放在双引号内，如果要的话要加“\”反斜杠2、查看PATH变量1echo $PATH 3、添加环境变量1export PATH="$PATH:/Users/..." 4、获取字符串长度1length=$&#123;#var&#125;]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT的使用（中间件的坑）]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%88%9B%E5%BB%BAtoken%2F</url>
    <content type="text"><![CDATA[关于JWT的坑 原理 验证机制（需用到 GetUserFromToken 中间件）1、根据用户信息，还有后面加入的信息创建token，并将token保存在后台的缓存，可加入 $user[&#39;now&#39;]=time() 等信息 2、将token发给客户端，存在客户端的缓存中 3、需要验证的操作或者请求使用jwt中间件验证（将存在客户端缓存中的token取出并放在 header 中发回给后台） 4、请求通过jwt中间件将 header 中的 token 值与后台缓存的token对比，确认一致后继续进行下一步操作 使用注意事项 一、使用中间件jwt.api.auth参考资料：http://blog.csdn.net/qq_28666081/article/details/52188549 1、改 config/auth.php 中的 &#39;providers&#39; 数组中的 model 为相应要验证的model名12345'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\Client::class, //Client为自己需要的model名 ], 2、model修改在创建的新 model 中加入以下1use Illuminate\Foundation\Auth\User as Authenticatable; 修改新 model 继承的类123class Client extends Authenticatable &#123; //Authenticatale替换原来的model ....&#125; 二、其他2、修改 config/jwt.php 文件的 &#39;user&#39; 项，改为要验证的model3、config/jwt.php 中的 &#39;ttl&#39; 属性为token的有效时间，根据需要设置 创建Token 方法1：用户登录的时候返回123456789101112131415161718192021222324use JWTAuth;use Tymon\JWTAuth\Exceptions\JWTException;class AuthenticateController extends Controller&#123; public function authenticate(Request $request) &#123; // grab credentials from the request $credentials = $request-&gt;only('email', 'password'); try &#123; // attempt to verify the credentials and create a token for the user if (! $token = JWTAuth::attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'invalid_credentials'], 401); &#125; &#125; catch (JWTException $e) &#123; // something went wrong whilst attempting to encode the token return response()-&gt;json(['error' =&gt; 'could_not_create_token'], 500); &#125; // all good so return the token return response()-&gt;json(compact('token')); &#125;&#125; 如果验证的密码字段不是 ‘password’，在要验证表的 model 中加入以下函数123public function getAuthPassword() &#123; return $this-&gt;user_password; //user_password为字段名&#125; 如果验证的用户字段字段不是 ‘email’ 是 ‘name’，在 ‘AuthController’ 中声明12345678//要这样验证$credentials = [ 'name' =&gt; $request-&gt;get('name'), 'password' =&gt; $request-&gt;get('password'), ];//加声明public $username = 'name'; （首选）方法2：通过用户对象实例创建token12$user = User::first(); //先获取用户$token = JWTAuth::fromUser($user);]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>JWTAuth</tag>
        <tag>dingo</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的增删改]]></title>
    <url>%2F2017%2F05%2F02%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Controller中 store, destory, update方法 如果是在/public/upload下的文件， 路径用 ./upload 1、增–store这里省去验证和文件上传步骤，详见laravel文件上传12345678910use App\modelName;public function store(newRequest $request)&#123; $content = $request-&gt;except('_token', 'fileName'); //不包括token和文件上传 $content['filename'] = 'URL' . 'newFilename' . $file-&gt;getClientOriginalExtension(); modelName::create($content); redirect('/path');&#125; 2、删–destory1234567891011121314151617use App\modelName;use File;public function destory($id)&#123; //先通过用户验证，进入相应用户的删除操作界面 $this -&gt; middleware('auth'); $content = modelName::find($id); //要删除的文件，引入File Facade File::delete('/path/fileName'); //删除数据库数据 $content -&gt; delete(); redirect('/path');&#125; 3、改–update改有两种方法可用，一种为直接新内容覆盖旧内容，另一种为逐条信息更新再update 第一种：覆盖 先不取出上传文件，后面处理后再加入数组，以下省略文件验证代码，详见larval文件上传123456789101112131415161718use App\modelName;use File;public function update(newRquest $request, $id)&#123; $url = 'url'; $file = $request-&gt;file('fileName'); $fileName = 'newFileName' . $file-&gt;getClientOriginalExtension(); $new_data = $request-&gt;all(); $file-&gt;move($url, $fileName); $new_data['filePath'] = $url . $fileName; $raw_data = modelName::findOrFail($id); File::delete($raw_data['filePath']); $raw_data-&gt;update($new_data);&#125; 第二种：逐条更新 缺点：要先在Controller中写好包含每列名称的关联数组12345678910111213141516171819202122use App\modelName;protected $column_names = [ 'column_name1' =&gt; '', 'column_name2' =&gt; '', 'column_name3' =&gt; '', 'column_name4' =&gt; '',];public function update(newRequest $request, $id)&#123; $raw_data = modelName::findOrFail($id); //取出键名 foreach(array_keys(array_except($this-&gt;column_names, ['column_namex'])) as $key) &#123; $raw_data-&gt;$key = $request-&gt;get($key); &#125; $raw_data -&gt; save(); redirect('/path');&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eloquent 关系]]></title>
    <url>%2F2017%2F05%2F02%2FEloquent-%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Eloquent 一对一等关系 1、设置外键（默认名称为user_id）1$table -&gt; integer('user_id') -&gt; default(1); //创建后第二个表中的所有数据都属于user表中id为1的用户 在链关系中如果最后一项为函数的话可以不用加( ) 2、创建关系 一对一关系 如果一个User模型与另一个model模型对应，定义一个method方法在User模型中，method方法调用Eloquent模型基类上hasOne方法并返回结果1234567891011&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; public function method() &#123; return $this-&gt;hasOne('App\model'); &#125;&#125; hasOne方法的第一个参数为关联模型的名称。通过动态属性访问关联方法：12$new = User::find(1)-&gt;method; //返回结果集，可以进一步调用属性$new = User::find(1)-&gt;method-&gt;name; //返回在models表中user_id为1的信息的名字 hasOne方法默认关联外键为user_id，如果想让model的其他作为外键，传入第二个参数：1return $this -&gt; hasOne('App\model', 'foreign_key'); hasOne方法默认通过id值去models表中查询user_id与之匹配的记录，如果想换主键匹配，传递第三个参数给hasOne:1return $this-&gt;hasOne('App\model', 'foreign_key', 'local_key'); 定义相对的关联也可以在model模型中定义关系关联User，使用belongsTo方法定义；1234567891011&lt;?php namespace App; use Illuminat\Database\Eloquent\Model; class model extends Model&#123; public function user() &#123; return $this-&gt;belongsTo('App\User'); &#125; &#125; 如果model模型上的外键不是user_id，父模型不使用id作为主键：1234public function user()&#123; return $this-&gt;belongsTo('App\User', 'foreign_key', 'other_primarykey');&#125; 用法1$new = App\model::find(1)-&gt;user(); //返回user表中id为1的信息 一对多关系 123456789101112&lt;?php namespace App; use Illuminate\Database\Eloquent\Model; //Posts表有id作为主键 class Post extends Model&#123; public function comments() &#123; return $this -&gt; hasMany('App\Comment'); &#125; &#125; Eloquent自动判断Comment模型的外键，默认某列中名称有_id后缀为外键访问关联方法（用法）：123456use App\Post;$comments = App\Post::find(1)-&gt;comments; //先用find找到一个用户，再调用函数foreach($comments as $comment)&#123; //&#125; 增加约束条件1$comments = App\Post::find(1)-&gt;comments()-&gt;where()-&gt;first; 通过第二个参数，第三个参数自定义外键和主键1return $this-&gt;hasMany('App\Comment', 'foreign_key', 'local_key'); 更多详见 laravelacademy.org/post/6996.html 只获取指定的字段 1return $this-&gt;belongsToMany(Permission::class)-&gt;select(array('name', 'description'));]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>Eloquent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 文件上传处理]]></title>
    <url>%2F2017%2F04%2F30%2Flaravel%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[Laravel文件上传操作 1.在blade文件中的表格指定文件上传的name1234&lt;form method="POST" action="url" enctype="multipart/form-data"&gt;&lt;input type="hidden" name="_token" value="&#123;&#123;csrf_token()&#125;&#125;"&gt;&lt;input type="file" name="newfile"&gt;&lt;input type="submit" name="sub"&gt; 2.改配置文件修改config/filesystems.php文件，加入以下代码1234567'uploads' =&gt; [ 'driver' =&gt; 'local', //文件上传到storage/app/uploads目录 'root' =&gt; storage_path('app/uploads'), //如果文件上传到public/uploads目录 则上一行代码换成下面一行 //'root' =&gt; public_path('uploads'),] 3.在Controller中获取文件信息并上传getClientOriginalName方法获取文件原名getRealPath( )方法获取缓存在tmp文件夹下的文件绝对路径getClientOriginalExtension( )方法获取上传文件的后缀getMimeType( )方法返回类似image/jpeg1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Storage;use App\Http\Requests;class FileController extends Controller&#123; // 文件上传方法 public function upload(Request $request) &#123; if ($request-&gt;isMethod('post')) &#123; $file = $request-&gt;file('picture'); // 验证文件是否上传成功并处理上传 if ($file-&gt;isValid()) &#123; /*****获取文件相关信息*****/ $originalName = $file-&gt;getClientOriginalName(); // 文件原名 $ext = $file-&gt;getClientOriginalExtension(); // 扩展名 $realPath = $file-&gt;getRealPath(); //临时文件的绝对路径 $type = $file-&gt;getClientMimeType(); // image/jpeg /**********************/ /*****上传文件*****/ $filename = date('Y-m-d-H-i-s') . '-' . uniqid() . '.' . $ext; // 使用新建的uploads本地存储空间（目录） $bool = Storage::disk('uploads')-&gt;put($filename, file_get_contents($realPath)); /****************/ var_dump($bool); &#125; &#125; return view('upload'); &#125;&#125; 4.注意(CSRF报错) laravel默认开启CSRF验证，不是get请求的话需要验证CSRF 解决办法1：加隐藏表单如果表单中加了以下1&lt;input type="hidden" name="_token" value="&#123;&#123;csrf_token()&#125;&#125;"&gt; 仍然报以下错误，用解决办法21TokenMismatchException in VerifyCsrfToken.php line 68: 解决办法2：禁用CSRF修改文件：app\Http\Kernel.php，注释掉以下代码1'App\Http\Middleware\VerifyCsrfToken' 可以直接使用 12$file = $request-&gt;file('filename');$file -&gt; move(public_path(),'/path', 'filename'); //移动到public/path下 验证上传图片类型并上传12345678910111213public function update(Request $request, $id)&#123; $content = $request-&gt;except('_token', 'filename'); if(!is_null($request-&gt;file('filename')))&#123; $this-&gt;validate($request, [ 'filename' =&gt; 'mimes:jpeg,png,gif' //filename为表单中file的name值 ]); $file = $request-&gt;file('filename'); //上传到指定文件夹 $file-&gt;move(public_path().'/path', 'newFileName'); //文件名最后补上后缀 &#125;&#125; validate方法接收一个HTTP请求输入数据和验证规则，如果验证规则通过，代码将会继续往下执行；然而，如果验证失败，将会抛出一个异常，相应的错误响应也会自动发送给用户。]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Route 相关]]></title>
    <url>%2F2017%2F04%2F30%2FRoute%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Route相关知识 项目中一般不用Route::resource( )Http方法patch对应Controller的update函数Http方法delete对应Controller的destory函数Http方法post对应Controller的store函数Http方法get且路径为/path/create对应Controller的create函数特殊:get路径为/path/{参数}/edit对应Controller的edit函数 部分资源路由（Resource）12Route::resource('new', 'newController', ['only'=&gt;['index', 'show']]); //只处理index和show方法Route::resource('new', 'newController', ['except'=&gt;['create', 'store']]); //处理除了create和store的方法 重定向到Controller Action12//第二个参数为可选参数return redirect() -&gt; action('MyController@index', ['id' =&gt; 1]);]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>Route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blade 相关]]></title>
    <url>%2F2017%2F04%2F29%2FBlade-Warning%2F</url>
    <content type="text"><![CDATA[一、blade实现编辑页面自动填充表单1. 在Controller中1$content = model名::findOrFail($id); 2. 在视图文件中使用Form-Model-Binding1&#123;!! Form::model($content, [&apos;method&apos;=&gt;&apos;PATCH&apos;, &apos;url&apos;=&gt;&apos;/path/&apos;.$content-&gt;id]) !!&#125; 二、Blade模板中的注意事项 如果从Controller传过来的数组为一维关联数组，可以直接用数组中的键作为变量 重用的代码放到一个文件里，在需要用的视图文件用@include(&#39;view&#39;s name&#39;) 三、视图绑定变量1、一般在被其他视图文件包含的视图文件使用，不用额外再写代码2、创建一个类文件，比如在App\ClassName3、在视图文件中用 @inject(&#39;var&#39;, &#39;ClassFile_Path&#39;) 绑定变量123@inject('var', 'App\ClassName')$var-&gt;method(); //调用ClassName类中的方法]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>blade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 函数]]></title>
    <url>%2F2017%2F04%2F29%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[有关laravel的函数 old( )函数old函数获取一次性从Session获取的值，如果有第二个参数，则代表函数当第一个参数不存在时取第二个参数 当表单被填充但是验证失败需要返回原始输入数据 12345//$fields为默认值的关联数组$data = [];foreach ($this-&gt;fields as $field =&gt; $default)&#123; $data[$field] = old($field, $default);&#125; array_except( )函数array_except方法从数组中移除给定键值对，第二个参数为[&#39;键名&#39;]1$array = array_except($array, ['price']); //移除array数组以`price`为键的键值对 array_keys( )函数array_keys函数返回包含数组中所有键名的一个新数组12$a = $array("name"=&gt;"lee", "sex"=&gt;"male");$b = array_keys($a); //b为array([0]=&gt;name, [1]=&gt;sex) withSuccess( )函数withSuccess函数参数为一个字符串语句，在重定向redirect( )后使用，在相应的视图文件中可用Session类获取12345//在控制器中 redirect('/path') -&gt; withSuccess('Succeed.');//在视图文件中 Session::has('success'); //判断是否存在 Session::get('success'); //获取控制器中withSuccess()中的字符串 strstr( )函数strstr函数查找第二个参数在第一个参数中第一次出现位置，并返回字符串剩余的部分12echo strstr('I love China.', 'love');//输出'love China' strtotime( )函数strtotime返回Unix时间戳1strtotime(date('Y-m-d H:i:s', time()));]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>blade</tag>
      </tags>
  </entry>
</search>