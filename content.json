{"meta":{"title":"Nancelglap","subtitle":"不想正经","description":"不想正经","author":"Nancelglap","url":"https://nancelglap.github.io"},"pages":[{"title":"关于 Nancelglap","date":"2017-06-19T02:40:26.000Z","updated":"2017-07-05T14:05:34.000Z","comments":true,"path":"about/index.html","permalink":"https://nancelglap.github.io/about/index.html","excerpt":"","text":"每天都活在梦里Wechat: NancelglaDclickQQ: 1037218107"},{"title":"tags","date":"2017-06-18T15:50:57.000Z","updated":"2017-06-18T15:50:57.000Z","comments":true,"path":"tags/index.html","permalink":"https://nancelglap.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql 定时备份","slug":"mysql-定时备份","date":"2017-06-20T14:48:28.000Z","updated":"2017-06-20T14:56:13.000Z","comments":true,"path":"2017/06/20/mysql-定时备份/","link":"","permalink":"https://nancelglap.github.io/2017/06/20/mysql-定时备份/","excerpt":"实现mysql定时备份","text":"实现mysql定时备份 1、创建备份文件夹1mkdir name 2、创建备份Shell脚本1$ vim filename.sh 3、加入以下内容（1）username 替换为实际的用户名(保留-u)（2）password 替换为实际的密码（保留-p）（3）DatabaseName 替换为实际的数据库名（4）/home/back改为自己的路径12#!/bin/bashmysqldump -uusername -ppassword DatabaseName &gt; /home/backup/DatabaseName_$(date +%Y%m%d_%H%M%S).sql 4、添加可执行权限1$ chmod u+x bkDatabaseName.sh 5、添加计划任务（改为自己创建的文件信息）123$ crontab -e*/1 * * * * /home/backup/bkDatabaseName.sh 6、执行时间前面五个*号代表五个数字，数字的取值范围和含义如下： 分钟 （0-59）小時 （0-23）日期 （1-31）月份 （1-12）星期 （0-6）//0代表星期天","categories":[{"name":"mysql","slug":"mysql","permalink":"https://nancelglap.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://nancelglap.github.io/tags/mysql/"},{"name":"backup","slug":"backup","permalink":"https://nancelglap.github.io/tags/backup/"}]},{"title":"微信公众号","slug":"微信公众号","date":"2017-06-20T12:51:52.000Z","updated":"2017-06-20T14:30:36.000Z","comments":true,"path":"2017/06/20/微信公众号/","link":"","permalink":"https://nancelglap.github.io/2017/06/20/微信公众号/","excerpt":"微信公众号开发相关","text":"微信公众号开发相关 参考资料：https://easywechat.org/https://github.com/overtrue/laravel-wechat 配置 1、注册相应路由和创建 Controller12345678910111213class WechatController extends Controller&#123; public function serve() &#123; $wechat = app('wechat'); $wechat-&gt;server-&gt;setMessageHandler(function($message)&#123; return \"您好！欢迎关注我!\"; &#125;); return $wechat-&gt;server-&gt;serve();&#125; 2、改 接口授权 -&gt; 网页授权获取用户基本信息 url 为服务器的域名 返回信息类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App\\Http\\Controllers;class WechatController extends Controller&#123; /** * 处理微信的请求消息 * * @return string */ public function serve() &#123; $wechat = app('wechat'); $userApi = $wechat-&gt;user; $wechat-&gt;server-&gt;setMessageHandler(function($message) use ($userApi)&#123; switch ($message-&gt;MsgType) &#123; case 'event': return '收到事件消息'; break; case 'text': return $userApi-&gt;get($message-&gt;FromUserName)-&gt;nickname; break; case 'image': return '收到图片消息'; break; case 'voice': return '收到语音消息'; break; case 'video': return '收到视频消息'; break; case 'location': return '收到坐标消息'; break; case 'link': return '收到链接消息'; break; // ... 其它消息 default: return '收到其它消息'; break; &#125; &#125;); return $wechat-&gt;server-&gt;serve(); &#125;&#125; 操作用户信息 1、自行完成路由注册，Controller 创建等操作2、更多用户操作见文档 https://easywechat.org/zh-cn/docs/user.html1234567891011121314151617181920212223242526272829303132333435363738394041use EasyWeChat\\Foundation\\Applications;class ControllerName extends Controller&#123; public $wechat; public function __construct(Applications $wechat) &#123; $this-wechat = $wechat; &#125; /** * 返回所有关注用户的openId */ public function users() &#123; $users = $this-&gt;wechat-&gt;user-&gt;lists(); return $users; &#125; /** * 返回单个已关注用户的信息 */ public function user($openId) &#123; $user = $this-&gt;wechat-&gt;user-&gt;get($openId); return $user; &#125; /** * 修改用户备注 （remark方法） */ public function remark($openId) &#123; $this-&gt;wechat-&gt;remark($openId, '备注信息'); return 'OK'; &#125;&#125; 管理公众号素材 1、自行注册路由和创建 Controller2、参考文档内容https://easywechat.org/zh-cn/docs/material.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253use EasyWeChat\\Foundation\\Applications;class ControllerName extends Controller&#123; public $material; public function __construct(Applications $material) &#123; $this-material = $material-&gt;material; &#125; /** * 上传public目录下的图片 */ public function image() &#123; $image = $this-&gt;material-&gt;uploadImage(public_path(). '/images/imageName.jpg'); return $image; &#125; /** * 上传public目录下的音频 */ public function audio() &#123; $audio = $this-&gt;material-&gt;uploadVoice(public_path. '/images/audioName.mp3'); //注意支持的格式 return $audio; return $user; &#125; /** * 查看所有上传了的图片信息 */ public function materials() &#123; $materials = $this-&gt;material-&gt;lists('image'); //返回其他素材看文档 return $materials; &#125; /** * 拿到特定素材信息 */ public function media($mediaId) &#123; $media = $this-&gt;material-&gt;get($mediaId); return $media; &#125;&#125; 3、当用户发音频信息，以客服身份返回信息（其他类型的信息类似）1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\Http\\Controllers;class WechatController extends Controller&#123; /** * 处理微信的请求消息 * * @return string */ public function serve() &#123; $wechat = app('wechat'); $userApi = $wechat-&gt;user; $wechat-&gt;server-&gt;setMessageHandler(function($message) use ($userApi, $wechat)&#123; switch ($message-&gt;MsgType) &#123; ... case 'voice': $message = new Voice(['media_id'] =&gt; '要返回的mediaId值'); //$message-&gt;FromUserName拿到用户的openId $wechat-&gt;staff-&gt;message($message)-&gt;to($message-&gt;FromUserName)-&gt;send(); return 'string'; break; ... &#125; &#125;); return $wechat-&gt;server-&gt;serve(); &#125;&#125;","categories":[{"name":"Wechat","slug":"Wechat","permalink":"https://nancelglap.github.io/categories/Wechat/"}],"tags":[{"name":"Wechat","slug":"Wechat","permalink":"https://nancelglap.github.io/tags/Wechat/"}]},{"title":"Laravel ACL","slug":"Laravel-ACL","date":"2017-06-16T08:13:41.000Z","updated":"2017-06-19T11:04:19.000Z","comments":true,"path":"2017/06/16/Laravel-ACL/","link":"","permalink":"https://nancelglap.github.io/2017/06/16/Laravel-ACL/","excerpt":"Laravel 实现 Access Control Lists","text":"Laravel 实现 Access Control Lists ACL权限 1、生成测试数据1234/*** modelFactory，生成用户自己的文章*/'user_id' =&gt; factory(App\\User::class)-&gt;create()-&gt;id, 2、修改 AuthServiceProvider 中的 boot 方法1234567891011121314151617181920212223242526272829public function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); $gate-&gt;define('show-post', function($user, $post)&#123; //登录来的用户id必须等于文章的user_id才有权限查看 return $user-&gt;id === $post-&gt;user_id; //$user为登录进来的用户，laravel自动检测 &#125;)&#125;/*** 对上述代码进行优化*///AuthServiceProvider.phppublic function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); $gate-&gt;define('show-post', function($user, $post)&#123; return $user-&gt;owns($post); &#125;)&#125;//User.phppublic function owns($post)&#123; return $this-&gt;id == $post-&gt;user_id;&#125; 3、在 controller 中应用认证12345678910111213public function show($id)&#123; $post = Post::findOrFail($id); Auth::loginUsingId(2); if(Gate::denies('show-post', $post))&#123; //show-post为在AuthServiceProvider中定义的名称 abort(403, 'Sorry'); //如果认证失败就返回403页面 &#125; //如果不用上面if方法，可以用以下 $this-&gt;authorize('show-post', $post); return $post-&gt;title;&#125; 4、在 blade 中应用认证（@can()标签）1234&lt;!-- 定义了 'show-post' 后只有传进来的$post符合验证规则才会显示标签内内容 --&gt;@can('show-post', $post)&lt;a href=\"#\"&gt;...&lt;/a&gt;@endcan 实现多个ACL权限 1、创建一个 与相应 model 对应的 policy1php artisan make:policy policyName 2、编写 app\\Policies\\policyName，在里面增加函数完成权限操作12345678910use App\\User;use App\\Post;...public function method(User $user, Post $post)&#123; return $user-&gt;owns($post); //owns在User的model中定义&#125; 3、启用 policy：在AuthServiceProvider 中的 $policies 数组中注册123456789protected $policies = [ /** * 在Controller中用Gate::denies('method', $post) * 根据第二个参数的类决定用哪个policy验证 * 再根据第一个参数用相应policy的method方法验证 */ 'App\\Post' =&gt; 'App\\Policies\\PolicyName',]; 4、运用 policy123456789101112131415161718192021222324/*** 去掉AuthServiceProvider中的以下部分*/$gate-&gt;define('show-post', function($user, $post)&#123; return $user-&gt;owns($post); &#125;)；/*** 修改Controller中的方法*/public function show($id)&#123; $post = Post::findOrFail($id); Auth::loginUsingId(2); //method为$post类对应的policyName中的验证函数 if(Gate::denies('method', $post))&#123; abort(403, 'Sorry'); &#125;&#125;/*** 如果blade中有@can标签，将参数改为验证函数名*/ 创建model和表 1、创建 Permission 和 Role model12345//权限php artisan make:model Permission//角色（规定某种权限）php artisan make:model Role 2、创建相应的表1php artisan make:migration create_roles_table --create=roles 3、编写 migration 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public function up()&#123; Schema::create('roles', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); //admin, member $table-&gt;string('label')-&gt;nullable(); //desription of name $table-&gt;timestamps(); &#125;); Schema::create('permissions', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); //admin, member $table-&gt;string('label')-&gt;nullable(); //desription of name $table-&gt;timestamps(); &#125;); /** * 关联 roles 和 permissions 表 */ Schema::create('permissions_role', function (Blueprint $table) &#123; $table-&gt;integer('permission_id')-&gt;unsigned(); $table-&gt;integer('role_id')-&gt;unsigned(); //创建外键 $table-&gt;foreign('permission_id') -&gt;references('id') -&gt;on('permissions') -&gt;onDelete('cascade'); $table-&gt;foreign('role_id') -&gt;references('id') -&gt;on('roles') -&gt;onDelete('cascade'); $table-&gt;primary(['permission_id', 'role_id']); //联合主键，只要两条数据两个字段不一样就行 &#125;); /** * 关联 roles 和 users 表 */ Schema::create('role_user', function (Blueprint $table) &#123; $table-&gt;integer('user_id')-&gt;unsigned(); $table-&gt;integer('role_id')-&gt;unsigned(); //创建外键 $table-&gt;foreign('user_id') -&gt;references('id') -&gt;on('users') -&gt;onDelete('cascade'); $table-&gt;foreign('role_id') -&gt;references('id') -&gt;on('roles') -&gt;onDelete('cascade'); $table-&gt;primary(['user_id', 'role_id']); //联合主键，只要两条数据两个字段不一样就行 &#125;);&#125; 4、执行 php artisan migrate 创建表之间的多对多关系 user: 用户，用户自己注册的账户，通过与role表的联系赋予用户角色（角色表与permission联系赋予用户权限） role：角色（admin, user等），用来描述user在该项目中的角色 permissions: 权限，用来描述一个角色拥有的权限，比如edit_form 1、修改 model 文件1234567891011121314151617181920212223242526272829/*** Permission*/public function roles()&#123; return $this-&gt;belongsToMany(Role::class);&#125;/*** Role*/public function permissions()&#123; return $this-&gt;belongsToMany(Permission::class);&#125;public function givePermission(Permission $permission)&#123; return $this-&gt;permissions()-&gt;save($permission); //通过 $role-&gt;givePermission($permission) 给角色权限&#125;/*** User*/public function roles()&#123; return $this-&gt;belongsToMany(Role::class);&#125; 2、进入 tinker 创建一个 role 角色和一个 permission 权限123456789101112131415161718php artisan tinker/*** 创建 role 为 admin*/namespace App;$role=new Role;$role-&gt;name=\"admin\"; //角色名$role-&gt;label=\"Admin\"; //角色描述$role-&gt;save();/*** 创建 permission 为 edit_form*/$permssion = new Permission;$permission-&gt;name = \"edit_form\"; //权限名$permission-&gt;label = \"Edit the form\"; //权限解释$permission-&gt;save(); 创建 权限 和 角色 后在 permission_role 中并没有将两个相关联 3、关联 权限 和 角色12//接着上面的tinker界面$role-&gt;givePermission($permission); //关系表中会生成自动关联数据 4、定义 权限1234567891011121314151617181920212223242526272829303132333435363738394041/*** AuthServiceProvider*/public function boot(GateContract $gate)&#123; $this-&gt;registerPolicies($gate); foreach($this-&gt;getPermissions() as $permission) &#123; $gate-&gt;define($permissions-&gt;name, function(User $user) use ($permission)&#123; return $user-&gt;hasRole($permission-&gt;roles); &#125;); &#125;&#125;protected function getPermissions()&#123; return Permission::with('roles')-&gt;get();&#125;/*** User model*/public function hasRole($role)&#123; /** * 在其他地方使用，如果传hasRole('admin')，既传进来的是字符串 */ if(is_string($role)) &#123; //判断user的所有role中是否存在name为$role的 return $this-&gt;roles-&gt;contains('name', $role); &#125; /** * 本例中使用，传进来的是roles的Collection */ // 1、判断user的role是否有与permission的role相同的 // 2、count返回 &gt;0 表明有用户有这个权限，取反再取反返回真 // 3、count返回 0 表明用户没有这个权限，取反再取反返回假 // 4、注意roles不要加括号，intersect方法处理的是Collection return !! $role-&gt;intersect($this-&gt;roles)-&gt;count(); &#125; 5、blade 应用1234&lt;!--在 AuthServiceProvider 中已经foreach注册了权限--&gt;@can('权限名')...@endcan 6、示例：赋予用户一个角色，让他拥有一定权限1234567php artisan tinkernamespace App;$user = User::find(1);$role = Role::find(1);$user-&gt;roles()-&gt;save($role); 7、应用实例：当用户注册时候自动赋予某个角色（角色和权限已经先在数据库定义好关系）123456789101112/*** 在 Controller 中*/public function register(RegisterRequest $request)&#123; $user = User::create($data); $role = Role::where('name', 'ordinary_user'); // 给注册用户 ordinary_user 这个角色 // 他的权限就是 ordinary_user 拥有的权限（在数据库预先定义好） $user-&gt;roles()-&gt;save($role);&#125; 使用 Middleware 实现后台管理 部分实现条件参考上面内容 1、创建 middleware1php artisan make:middleware NameOfMiddleware 2、在 middleware 的 handle 方法中实现代码逻辑123456789101112131415161718public function handle($request, Closure $next)&#123; //$request-&gt;user()就是Auth::user()作用 if($request-&gt;user() &amp;&amp; $request-&gt;user()-&gt;isAdmin()) &#123; return $next($request); &#125; //没通过认证就重定向回首页 return redirect('/');&#125;/*** 到 User model 中声明 isAdmin()方法*/public function isAdmin()&#123; return $this-&gt;hasRole('admin'); //hasRole参考上面内容&#125; 3、注册 middleware1234567/*** app\\Http\\Kernel.php*/protected $routeMiddleware = [ ... 'name' =&gt; \\App\\Http\\Middleware\\NameOfMiddleware::class,] 4、使用 middleware1234567891011121314151617181920/*** 方法一：在 Route 中使用* name 是在注册时规定的名称*/Route::get('/', ['middleware' =&gt; 'name'], function() &#123; ...;&#125;)/*** 方法二：在 Controller 中使用* 在 __construct() 中使用*/public function __construct()&#123; //name 是在注册时规定的名称 $this-&gt;middleware('name'); //指定只有几个方法运用middleware $this-&gt;middleware('name', ['only' =&gt; ['store', 'update']]);&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"ACL","slug":"ACL","permalink":"https://nancelglap.github.io/tags/ACL/"},{"name":"authorize","slug":"authorize","permalink":"https://nancelglap.github.io/tags/authorize/"},{"name":"Middleware","slug":"Middleware","permalink":"https://nancelglap.github.io/tags/Middleware/"}]},{"title":"Laravel 项目实战相关","slug":"Laravel-项目实战相关","date":"2017-06-12T13:41:08.000Z","updated":"2017-06-20T00:15:09.000Z","comments":true,"path":"2017/06/12/Laravel-项目实战相关/","link":"","permalink":"https://nancelglap.github.io/2017/06/12/Laravel-项目实战相关/","excerpt":"与 Laravel 实际项目相关内容","text":"与 Laravel 实际项目相关内容 在Controller中重定向Controller中的方法 1return redirect()-&gt;action('NameController@method', ['param' =&gt; 'value']); 在 Controller 中使用 middleware 123456789101112/*** Controller*/public function __construct()&#123; $this-&gt;middleware('auth', ['only' =&gt; ['create', 'store', 'edit', 'update']]); //只用在四种方法上&#125;/*** app\\Http\\Middleware\\Authenticate.php*/return redirect()-&gt;guest('返回的路由'); 更新数据内容 将原来的内容填入编辑表单中（使用Form::model）123456789/*** edit.blade.php*/&#123;&#123; Form::model($comment, ['method' =&gt; 'post', 'url' =&gt; '/comment/'.$comment-&gt;id]) &#125;&#125;/*** 点击更改的url'/comment/edit/$comment-&gt;id'，* Route::post('/comment/edit/&#123;id&#125;')*/ 更新数据方法12$comment = comment::findOrFail($id);$comment-&gt;update($request-&gt;all()); 设置只有发表评论的人才能更新123456789101112131415161718/*** Controller*/public function edit($id)&#123; $comment = comment::findOrFail($id); if(Auth::user()-&gt;id !== $comment-&gt;user_id) &#123; return redirect('/'); &#125;&#125;/*** Blade*/@if(Auth::check() &amp;&amp; Auth::user() -&gt; id == $comment-&gt;user_id) ...@endif 实现评论一：创建表以及完成之间的联系 1、migration 文件的设置123456789101112131415161718/*** comment表*/$table-&gt;increments('id');$table-&gt;text('body');$table-&gt;integer('user_id')-&gt;unsigned();$table-&gt;integer('discussion_id')-&gt;unsigned();//创建外键$table-&gt;foreign('user_id') -&gt;references('id') //连接的主键字段为id -&gt;on('users') //连接的表为users -&gt;onDelete('cascade');$table-&gt;foreign('discussion_id') -&gt;references('id') -&gt;on('discussions') -&gt;onDelete('cascade');$table-&gt;timestamps(); 2、 model 文件建立联系123456789101112131415161718192021222324252627282930313233/*** User model*/public function discussions()&#123; return $this-&gt;hasMany(Discussion::class); //$user-&gt;disscussions拿到所有发布&#125;public function comments()&#123; return $this-&gt;hasMany(Comment::class); //$user-&gt;comments拿到所有评论&#125;/*** Comment model*/public function disscussion()&#123; return $this-&gt;belongsTo(User::class);&#125;/*** Discussion model*/public function user()&#123; return $this-&gt;belongsTo(User::class);&#125;public function comments()&#123; return $this-&gt;hasMany(Comment::class);&#125; 实现评论二、存储评论 并 限制展示评论框 1、评论存储要带上依附内容的 id 存入数据库1234567/*** 1、评论提交的时候就要带上文章内容的id，可以用隐藏表单（数据库中要有这个字段）* 2、存入数据库带上评论用户的id*/&#123;!! Form::hidden('id', $article-&gt;id) !!&#125;Comment::create(array_merge($request-&gt;all(), ['user_id' =&gt; Auth::user()-&gt;id])); 2、如果用户没有登录不展示评论框12345678/*** blade */@if(Auth::check()) ... //展示评论框@else &lt;a href=\"/user/login\" class=\"btn btn-block btn-success\"&gt;登录&lt;/a&gt;@endif 实现下拉菜单 123456789101112131415161718192021&lt;!--app.blade.php--&gt;&lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\"&gt;&lt;link href=\"http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css\" rel=\"stylesheet\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/style.css\"&gt;&lt;li&gt; &lt;a id=\"dLabel\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"ture\"&gt; &#123;&#123; Auth::user()-&gt;name &#125;&#125; &lt;/a&gt; &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dLabel\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt; &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 更换头像&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt; &lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; 更换密码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt; &lt;i class=\"fa fa-heart\"&gt;&lt;/i&gt; 特别感谢&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"/logout\"&gt; &lt;i class=\"fa fa-sign-out\"&gt;&lt;/i&gt; 退出登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;script src=\"//cdn.bootcss.com/jquery/3.0.0-alpha1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"&gt;&lt;/script&gt; 集成 markdown 编辑器 1、在 composer.json 的require里加入，执行composer update1\"yuanchao/laravel-5-markdown-editor\": \"dev-master\" 2、在 config/app.php 的 providers 数组加入一条1'YuanChao\\Editor\\EndaEditorServiceProvider' 3、在 config/app.php 的 aliases 数组加入一条1'EndaEditor' =&gt; 'YuanChao\\Editor\\Facade\\EndaEditorFacade' 4、执行 php artisan vendor:publish --tag=EndaEditor 5、修改需要编辑器的页面12345678//引入编辑器代码，必须在引入头文件前引入jquery文件！！！！&lt;script src=\"//cdn.bootcss.com/jquery/3.0.0-alpha1/jquery.min.js\"&gt;&lt;/script&gt; @include('editor::head')//创建一个 class 为 editor 的容器&lt;div class=\"editor\"&gt; &#123;!! Form::textarea('content', '', ['class' =&gt; 'form-control','id'=&gt;'myEditor']) !!&#125;&lt;/div&gt; 以下为配置图片上传6、修改 \\config\\editor.php，并注册路由12345//修改config\\editor.php配置'uploadUrl' =&gt; 'post/upload' //放到PostsController中//注册路由Route::post('/post/upload', 'PostsController@upload'); 7、在 PostsController 中创建 upload 方法1234567use EndaEditor; //在头部加上public function upload()&#123; $data = EndaEditor::uploadImgFile('uploads'); //上传目录为\\public\\uploads return json_encode($data); &#125; 8、如果出现上传图片时候黑屏，删掉 resource\\views\\vendor\\editor\\head.blade.php 中的1&lt;script src=\"....bootstrap.js\"&gt;&lt;/script&gt; 引用 Markdown 和第三方库 1、复制https://github.com/SegmentFault/HyperDown Parser.php 文件2、创建一个 Class app\\Markdown\\Parser.php，将复制的代码粘贴进去，声明命名空间1namespace App\\Markdown; 3、创建一个 Class app\\Markdown\\Markdown.php1234567891011121314151617class Markdown &#123; protected $parser; public function __construct(Parser $parser) &#123; $this-&gt;parser = $parser; &#125; public function markdown($text) &#123; $html = $this-&gt;parser-&gt;makeHtml($text); return $html; &#125;&#125;//将新文件加载到autoload文件里面composer dump-autoload 4、在 Controller 中引入 Markdowwn 类123456789101112131415161718192021use App\\Markdown\\Markdown;class NameController extends Controller&#123; protected $markdown; public function __construct(Markdown $markdown) &#123; $this-&gt;markdown = $markdown; &#125; /** * 在某个展示方法中使用 */ public function show($id) &#123; $comment = comment::findOrFail($id); $html = $this-&gt;markdown-&gt;markdown($comment-&gt;content); return view('show', compact('comment', 'html')); &#125;&#125; 5、在 blade 文件中输出内容1&#123;&#123; $html &#125;&#125; 实现收藏内容功能 1、创建关系表1234567php artisan make:model Favorite -m/*** migration*/$table-&gt;integer('user_id')-&gt;unsigned();$table-&gt;integer('article_id')-&gt;unsigned(); 2、建立多对多关系12345678/*** User model*/public function favorites()&#123; //第二个参数为关系表名，如果不传默认找article_user表 $thie-&gt;belongsToMany(Article::class, 'favorites')-&gt;withTimestamps();&#125; 3、展示内容（可以在 Route 完成，也可以在 Controller 中完成）12345678910Route::get('/article', function()&#123; $articles = Article::latest(); if(Auth::check()) &#123; $favorites = Favorites::where('user_id', Auth::user()-&gt;id) -&gt;lists('article_id')-&gt;toArray(); &#125; return view('index', compact('articles', 'favorites'));&#125;); 4、在视图文件创建收藏模块1234567891011121314@if(Auth::check()) @if(in_array($article_id, $favorites)) &lt;!--取消收藏--&gt; &#123;!! Form::open(['url' =&gt; '/path2']) !!&#125; &#123;!! Form::hidden('article_id', $article-&gt;id) !!&#125; @else &lt;!--收藏--&gt; &#123;!! Form::open(['url' =&gt; '/path1']) !!&#125; &#123;!! Form::hidden('article_id', $article-&gt;id) !!&#125; @endif &lt;button type=\"submit\"&gt;&lt;i class=\"fa fa-heart &#123;&#123; in_array($article-&gt;id, $favorites? 'favorited' : 'not-favorited') &#125;&#125;\"&gt;&lt;/i&gt;&lt;/button&gt; &#123;!! Form::close() !!&#125;@endif &lt;!--展示内容--&gt; 增加css123456.favorited, not-favorited:hover&#123; color: red;&#125;.not-favorited, .favorited:hover&#123; color: #000;&#125; 5、完成 收藏内容 和 取消收藏 内容方法以及 登录保护12345678910111213141516171819202122/*** Controller*/public function __construct()&#123; $this-&gt;middleware('auth'); //只有用户登录才可以完成收藏和取消收藏&#125;public function store(Request $request)&#123; Auth::user()-&gt;favorites()-&gt;attach($request-&gt;get('article_id')); return redirect()-&gt;back();&#125;public function cancel_store(Request $request)&#123; Auth::user()-&gt;favorites()-&gt;detach($request-&gt;get('article_id')); return redirect()-&gt;back();&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"project","slug":"project","permalink":"https://nancelglap.github.io/tags/project/"},{"name":"mixture","slug":"mixture","permalink":"https://nancelglap.github.io/tags/mixture/"}]},{"title":"laravel 用户注册登录相关","slug":"laravel-用户注册登录相关","date":"2017-06-11T12:18:31.000Z","updated":"2017-06-19T11:22:11.000Z","comments":true,"path":"2017/06/11/laravel-用户注册登录相关/","link":"","permalink":"https://nancelglap.github.io/2017/06/11/laravel-用户注册登录相关/","excerpt":"laravel实现用户注册和登录以及用户信息相关","text":"laravel实现用户注册和登录以及用户信息相关 实现密码自动加密 在 user 表中使用 attribute1234public function setPasswordAttribute($password)&#123; $this-&gt;attributes['password'] = Hash::make($password);&#125; 登录 12345678/*** controller文件*/if(Auth::attempt([ 'email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password'), //在model中定义了Attribute用Hash加密，所以不用在此不用加密 'is_confirmed' =&gt; 1])) 登出 12Auth::logout();JWToken::refresh(); 提示登录错误信息 12345678910111213/*** Controller文件*/Session::flash('id', '错误信息');/*** blade文件*/@if(Session::has('id'))&lt;div class=\"alert alert-danger\" role=\"alert\"&gt; &#123;&#123; Session::get('id') &#125;&#125;&lt;/div&gt;@endif 信息错误后将用户填写的信息返回给原来的页面 1return redirect('/user/login')-&gt;withInput(); 修改错误提示 打开 resources\\lang\\en\\validation.php 修改 custom 数组123456//以下为当name为id的字段为空时提示“用户名不能为空”'custom' =&gt; [ 'name' =&gt; [ 'required' =&gt; '用户名不能为空' ]] 登录后blade显示用户信息 12345@if(Auth::check()) &#123;&#123; Auth::user()-&gt;name &#125;&#125;@else ...@endif 传统修改头像 1、引用 intervention/image packagehttps://github.com/Intervention/image1composer require intervention/image 2、修改 config\\app.php 文件1234567891011121314/*** $providers数组*/Intervention\\Image\\ImageServiceProvider::class/*** $aliases数组*/'Image' =&gt; Intervention\\Image\\Facades\\Image::class/*** 生成文件*/php artisan vendor:publish --provider=\"Intervention\\Image\\ImageServiceProviderLaravel5\" 3、表单1234&#123;!! Form::open(['url' =&gt; '/avatar', 'files'=&gt;true]) !!&#125;&#123;!! Form::file('avatar') !!&#125;&#123;!! Form::submit('上传头像', ['class' =&gt; 'btn btn-primary pull-right'])!!&#125;&#123;!! Form::close() !!&#125; 4、修改 controller123456789101112131415use Image; //引用上面引入的packagepublic function changeAvatar(Request $request)&#123; $file = $requet-&gt;file('avatar'); $path = 'uploads/'; //在public目录下创建一个uploads目录 $filename = time().$file-&gt;getClientOriginalName(); $file-&gt;move($path, $filename); Image::make($path.$filename)-&gt;fit(200)-&gt;save(); //将图片修改为200 x 200大小的图片 $user = User::find(Auth::user()-&gt;id); $user-&gt;avatar = '/'.$path.$filename; $user-&gt;save(); return redirect('path');&#125; 5、给目录权限1chmod -R 777 uploads/ 用 Ajax 完成修改头像 实现上传头像过程按钮变化并在上传后自动更换头像 1、在 app.blade.php 中引入文件，将文件放到 public\\js 中https://github.com/JellyBool/laravel-app123&lt;script src=\"/js/jquery-2.1.4.min.js\"&gt;&lt;/script&gt;&lt;script src=\"/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;script src=\"/js/jquery.form.js\"&gt;&lt;/script&gt; 2、修改头像的 blade 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class=\"text-center\"&gt; &lt;div id=\"validation-errors\"&gt;&lt;/div&gt; &lt;img src=\"&#123;&#123;Auth::user()-&gt;avatar&#125;&#125;\" width=\"120\" class=\"img-circle\" id=\"user-avatar\" alt=\"\"&gt; &#123;!! Form::open(['url'=&gt;'/avatar','files'=&gt;true,'id'=&gt;'avatar']) !!&#125; &lt;div class=\"text-center\"&gt; &lt;button type=\"button\" class=\"btn btn-success avatar-button\" id=\"upload-avatar\"&gt;上传新的头像&lt;/button&gt; &lt;/div&gt; &#123;!! Form::file('avatar',['class'=&gt;'avatar','id'=&gt;'image']) !!&#125; &#123;!! Form::close() !!&#125; &lt;div class=\"span5\"&gt; &lt;div id=\"output\" style=\"display:none\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;$(document).ready(function() &#123; var options = &#123; beforeSubmit: showRequest, success: showResponse, dataType: 'json' &#125;; $('#image').on('change', function()&#123; $('#upload-avatar').html('正在上传...'); $('#upload').ajaxForm(options).submit(); &#125;); &#125;); function showRequest() &#123; $(\"#validation-errors\").hide().empty(); $(\"#output\").css('display','none'); return true; &#125; function showResponse(response) &#123; if(response.success == false) &#123; var responseErrors = response.errors; $.each(responseErrors, function(index, value) &#123; if (value.length != 0) &#123; $(\"#validation-errors\").append('&lt;div class=\"alert alert-error\"&gt;&lt;strong&gt;'+ value +'&lt;/strong&gt;&lt;div&gt;'); &#125; &#125;); $(\"#validation-errors\").show(); &#125; else &#123; $('#user-avatar').attr('src',response.avatar); &#125; &#125; 3、修改 controller 文件12345678910111213141516171819202122232425262728293031323334use Image; //引用上面引入的packageuse Illuminate\\Support\\Facades\\Response;use Validator;public function changeAvatar(Request $request)&#123; $file = $requet-&gt;file('avatar'); $input = array('image' =&gt; $file); $rules = array( 'image' =&gt; 'image' ); $validator = Validator::make($input, $rules); if ( $validator-&gt;fails() ) &#123; return Response::json([ 'success' =&gt; false, 'errors' =&gt; $validator-&gt;getMessageBag()-&gt;toArray() ]); &#125; $path = 'uploads/'; //在public目录下创建一个uploads目录 $filename = time().$file-&gt;getClientOriginalName(); $file-&gt;move($path, $filename); Image::make($path.$filename)-&gt;fit(200)-&gt;save(); //将图片修改为200 x 200大小的图片 $user = User::find(Auth::user()-&gt;id); $user-&gt;avatar = '/'.$path.$filename; $user-&gt;save(); return Response::json([ 'success' =&gt; true, 'avatar' =&gt; asset($path.$filename), ]);&#125; 实现上传头像的裁剪 1、引入 Jcrop 文件（\\public\\css\\jquery.Jcrop.css 和 \\public\\js\\jquery.Jcrop.min.js）https://github.com/JellyBool/laravel-app12&lt;link rel=\"stylesheet\" href=\"/css/jquery.Jcrop.css\"&gt;&lt;script src=\"/js/jquery.Jcrop.min.js\"&gt;&lt;/script&gt; 2、在 blade 中引入一个bootstrap的 model（注意创建路由指向方法为cropAvatar）12345678910111213141516171819202122232425262728293031&lt;div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\"&gt; &lt;div class=\"modal-dialog\" role=\"document\"&gt; &lt;div class=\"modal-content\"&gt; &#123;!! Form::open( [ 'url' =&gt; ['/crop/api'], 'method' =&gt; 'POST', 'onsubmit'=&gt;'return checkCoords();','files' =&gt; true ] ) !!&#125; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;span aria-hidden=\"true\" style=\"color: #ffffff\"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=\"modal-title\" id=\"exampleModalLabel\"&gt;裁剪头像&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"crop-image-wrapper\"&gt; &lt;img src=\"/images/default-avatar.png\" class=\"ui centered image\" id=\"cropbox\" &gt; &lt;input type=\"hidden\" id=\"photo\" name=\"photo\" /&gt; &lt;input type=\"hidden\" id=\"x\" name=\"x\" /&gt; &lt;input type=\"hidden\" id=\"y\" name=\"y\" /&gt; &lt;input type=\"hidden\" id=\"w\" name=\"w\" /&gt; &lt;input type=\"hidden\" id=\"h\" name=\"h\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;取消&lt;/button&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;裁剪头像&lt;/button&gt; &lt;/div&gt; &#123;!! Form::close() !!&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3、实现 controller 中的函数1234567891011121314151617181920212223242526272829303132333435/*** 为了实现裁剪后才将图片保存，去掉传统头像上传的 *`changeAvatar`* 方法中的三行* 修改 Response::json*/$user = User::find(Auth::user()-&gt;id);$user-&gt;avatar = '/'.$path.$filename;$user-&gt;save();return Response::json([ 'success' =&gt; true, 'avatar' =&gt; asset($path.$filename), 'image' =&gt; $path.$filename //让js中的photo变量为图片路径 ]);/*** 增加 cropAvatar函数*/public fuction cropAvatar(Request $request)&#123; $photo = $request-&gt;get('photo'); //在js文件中photo变量已经设为图片路径 $width = (int) $request-&gt;get('w'); $heigth = (int) $request-&gt;get('h'); $xAlign = (int) $request-&gt;get('x'); $yAlign = (int) $request-&gt;get('y'); Image::make($photo)-&gt;crop($width, $height, $xAlign, $yAlign)-&gt;save(); $user = Auth::user(); //给 blade &lt;img src&gt; 处理路径最前面要带上斜杠，所以要使用asset方法，用http方式补全 $user-&gt;avatar = asset($photo); $user-&gt;save(); return redirect('user/avatar'); //用户更换头像页面&#125; 4、修改 blade 文件（前部分代码看传统上传中的blade文件）123456789101112131415161718192021222324252627282930/*** 修改blade文件中的ShowResponse方法，将else部分换为以下部分，并加入两个函数*/else&#123; var cropBox = $(\"#cropbox\"); cropBox.attr('src',response.avatar); $('#photo').val(response.image); //让blade提交表单时候photo变量为图片路径 $('#upload-avatar').html('更换新头像'); $('#exampleModal').modal('show'); cropBox.Jcrop(&#123; aspectRatio: 1, onSelect: updateCoords, setSelect: [120,120,10,10] &#125;); $('.jcrop-holder img').attr('src',response.avatar);&#125;function updateCoords(c)&#123; $('#x').val(c.x); $('#y').val(c.y); $('#w').val(c.w); $('#h').val(c.h);&#125;function checkCoords()&#123; if (parseInt($('#w').val())) return true; alert('请选择图片.'); return false;&#125; 实现第三方登录 https://github.com/overtrue/socialite 示例github1、到github注册一个Application setting -&gt; Applications -&gt; Register new application2、填写信息：callback url为请求成功后跳转的地址3、引用package1$ composer require \"overtrue/socialite:~1.0\" 4、注册路由12Route::get('/login', 'LoginController@github'); //认证Route::get('/github/login', 'LoginController@githubLogin'); //获取信息 5、完成认证和获取信息方法123456789101112131415161718192021222324252627282930313233/*** Controller*/protected $config = [ 'github' =&gt; [ 'client_id' =&gt; 'your-app-id', 'client_secret' =&gt; 'your-app-secret', 'redirect' =&gt; 'github注册的callback url', ],];public function github()&#123; /** * 该方法检查client_id和client_secret是否一致 * 一致就返回授权用户的信息给callback url */ $socialite = new SocialiteManager($this-&gt;config); return $socialite-&gt;driver('github')-&gt;redirect(); //跳转到github验证页面&#125;public function githubLogin()&#123; $socialite = new SocialiteManager($this-&gt;config); $githubUser = $socialite-&gt;driver('gtihub')-&gt;user(); /** * $githubUser为授权用户的信息 * $githubUser-&gt;getId(); * $githubUser-&gt;getNickname(); * $githubUser-&gt;getName(); * $githubUser-&gt;getEmail(); */&#125; 实现用户名或邮箱登录 12345678910111213141516public function login(Request $request)&#123; // 1、login为要验证的表单id // 2、验证是邮箱还是用户名 $option = filter_var($request-&gt;get('login'), FILTER_VALIDATE_EMAIL) ? 'email':'name'; $request-&gt;merge([$option =&gt; $request-&gt;get('login')]); if(Auth::attempt($request-&gt;only($option, 'password'))) &#123; //验证通过后的代码... return ...; &#125; //验证不通过的处理 ...;&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"user","slug":"user","permalink":"https://nancelglap.github.io/tags/user/"},{"name":"register","slug":"register","permalink":"https://nancelglap.github.io/tags/register/"},{"name":"login","slug":"login","permalink":"https://nancelglap.github.io/tags/login/"},{"name":"profile","slug":"profile","permalink":"https://nancelglap.github.io/tags/profile/"}]},{"title":"laravel Request常用规则","slug":"laravel-Request常用规则","date":"2017-06-11T12:09:33.000Z","updated":"2017-06-19T11:04:26.000Z","comments":true,"path":"2017/06/11/laravel-Request常用规则/","link":"","permalink":"https://nancelglap.github.io/2017/06/11/laravel-Request常用规则/","excerpt":"","text":"&#39;name&#39; =&gt; &#39;required|min:3&#39;&#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39; 规定 users 表的 email 字段必须为唯一password =&gt; &#39;required|min:6|confirmed&#39;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"request","slug":"request","permalink":"https://nancelglap.github.io/tags/request/"}]},{"title":"laravel 表的联系","slug":"laravel-表的联系","date":"2017-06-11T07:45:36.000Z","updated":"2017-06-19T11:04:10.000Z","comments":true,"path":"2017/06/11/laravel-表的联系/","link":"","permalink":"https://nancelglap.github.io/2017/06/11/laravel-表的联系/","excerpt":"设置laravel 数据表之间的联系","text":"设置laravel 数据表之间的联系 1、创建一个跟用户联系的表，用 user_id ， last_user_id 作为外键123456789101112131415161718192021/*** Comment表*/$table -&gt; increments('id');$table -&gt; string('title');$table -&gt; text('body');$table -&gt; integer('user_id')-&gt;unsigned();$table -&gt; integer('last_user_id')-&gt;unsigned();$table -&gt; foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade'); //规定user_id为users表id字段的连接$table -&gt; timestamps();/*** users表*/$table -&gt; increments('id');$table -&gt; string('name');$table -&gt; string('avatar'); //用户头像url$table -&gt; string('email')-&gt;unique();$table -&gt; string('password', 60);$table -&gt; remremberToken();$table -&gt; timestamps(); 2、创建 users 表测试数据123456789101112131415$factory-&gt;define(App\\User::class, function (Faker\\Generator $faker) &#123; static $password; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, 'avatar' =&gt; $faker-&gt;imageUrl(256, 256), 'password' =&gt; $password ?: $password = bcrypt('secret'), 'remember_token' =&gt; str_random(10), ];&#125;);php artisan tinkernamespace App;factory(user::class, 30)-&gt;create(); 3、创建 comments 表测试数据1234567891011121314$factory-&gt;define(App\\comment::class, function (Faker\\Generator $faker) &#123; $user_ids = \\App\\User::pluck('id')-&gt;toArray(); //将users表中的id拿出来作为数组 return [ 'title' =&gt; $faker-&gt;sentence, 'body' =&gt; $faker-&gt;paragraph, 'user_id' =&gt; $faker-&gt;randomElement($user_ids), 'last_user_id' =&gt; ($faker-&gt;randomElement($user_ids))[0], ];&#125;);php artisan tinkernamespace App;factory(comment::class, 30)-&gt;create(); 在model中建立关系 1、修改 users 表model文件，使用Eloquent Relationship1234public function comments()&#123; return $this-&gt;hasMany(comment::class); //使用$user-&gt;comments()获取用户所有评论&#125; 2、修改 comment 表model文件，使用Eloquent Relationship12345public function user()&#123; //默认外键为user_id，如果有自定义外键作为第二个参数传入 return $this-&gt;belongsTo(User::class); //使用$comment-&gt;user()获取评论的用户&#125; 多对多关系 belongsToMany()第二个参数为两个表关系的表名，如果没有三四个参数，关系表的两个字段为model1_id, model2_id（小写），model1为belongsToMany所在的model 1、创建第三方关联表1234567891011$table-&gt;integer('article_id')-&gt;unsigned();$table-&gt;integer('tag_id')-&gt;unsigned();$table-&gt;foreign('article_id') -&gt;references('id') -&gt;on('articless') -&gt;onDelete('cascade');$table-&gt;foreign('tag_id') -&gt;references('id') -&gt;on('tags') -&gt;onDelete('cascade'); 2、在 model 文件中声明多对多关系123456789101112131415/*** Article*/public function tags()&#123; return $this-&gt;belongsToMany(Tag::class);&#125;/*** Tag*/public function articles()&#123; return $this-&gt;belongsToMany(Article::class);&#125; 3、建立关系123456789101112/*** 比如在Controller中* 以下操作都会在第三方表中自动生成数据*///将 articles 表 id 为3的与 tags 表 id 为2的绑定$article = App\\Article::find(3);$article-&gt;tags()-&gt;attach(2);//将 articles 表 id 为3的与 tags 表 id 为2的解除绑定$article = App\\Article::find(3);$article-&gt;tags()-&gt;detach(2);","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"database","slug":"database","permalink":"https://nancelglap.github.io/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://nancelglap.github.io/tags/mysql/"},{"name":"table","slug":"table","permalink":"https://nancelglap.github.io/tags/table/"}]},{"title":"laravel 用户确认邮箱","slug":"laravel-用户确认邮箱","date":"2017-06-10T02:57:00.000Z","updated":"2017-06-19T11:04:07.000Z","comments":true,"path":"2017/06/10/laravel-用户确认邮箱/","link":"","permalink":"https://nancelglap.github.io/2017/06/10/laravel-用户确认邮箱/","excerpt":"用laravel完成用户确认邮箱完成认证","text":"用laravel完成用户确认邮箱完成认证 1、在 composer.json 中加入以下内容并执行 composer update1234\"require\": &#123; ... , \"guzzlehttp/guzzle\": \"~5.3|~6.0\",&#125; 2、用 MandDrill driver来发送邮件，在mandrill注册后拿到 secret_key（也可以用sendcloud）3、配置 .env 文件12MAIL_DRIVER=mandrillMANDRILL_SECRET=拿到的secret key 4、配置 mail.php1'from' =&gt; ['address' =&gt; '发送email的邮箱', 'name' =&gt; '名字'] 5、在 migration 文件中给表增加两个字段，并在 model 文件中将字段加入 $fillable 数组中1234567891011/*** migration文件*/$table-&gt;string('confirm_code', 64);$table-&gt;integer('is_confirmed')-&gt;default(0); //0代表没激活，1代表已激活/*** model文件*/protected $fillable = [... , 'confirm_code']; 6、用 ModelFactory 添加测试信息（测试用，可跳过）1234567891011/*** 在ModelFactory文件中加入*/'confirm_code' =&gt; str_random(48),/*** 用php artisan tinker生成数据*/php artisan tinkernamespace App;factory(modelName::class, 30)-&gt;create(); 7、编写 Controller 文件123456789101112131415161718192021public function store(yourRequest $request)&#123; $data = [ 'confirm_code' =&gt; str_random(48), ] $user = modelName::create(array_merge($request-&gt;all(), $data)); $subject = '内容'; $view = 'email.register'; //传views\\email\\register.blade.php $this-&gt;sendTo($user, $subject, $view, $data); //在后面生成sendTo方法 return redirect('/');&#125;private function sendTo($user, $subject, $view, $data = [])&#123; Mail::queue($view, $data, function($message) use ($user, $subject)&#123; $message-&gt;to($user-&gt;email)-&gt;subject($subject); //$user-&gt;email为用户注册填写的email &#125;);&#125; 8、编写 Controller ：文件当用户点击链接时的处理函数123456789101112131415public function confirmEmail($confirm_code)&#123; $user = User::where('confirm_code', $confirm_code)-&gt;first(); if(is_null($user)) &#123; return redirect('/'); &#125; //如果有查找到用户将认证设置为1，并再生成一个confirm_code确保下次点击url时无效 $user-&gt;is_confirmed = 1; $user-&gt;confirm_code = str_random(48); $user-&gt;save(); return redirect('user/login');&#125; 9、生成发送给用户的url 和 设置路由123456789/*** 在视图中生成url*/&lt;a href=\"&#123;&#123; url('verify/'. $confirm_code) &#125;&#125;\"&gt;Click To Confirm&lt;/a&gt; //sendTo函数包含$confirm_code参数/*** 生成路由*/Route::get('verify/&#123;confirm_code&#125;', 'nameController@confirmEmail'); 重构邮件发送类(用event)并集成 SendCloud 邮件服务 一、重构邮件发送类1、在 model 中定义方法取代 modelName::create()1234567public static function register(array $array) //array为用户数据构成的数组&#123; $user = static::create($array); event(new EventName($user)); //触发事件完成listener中handle方法内容 return $user;&#125; 2、在 event 文件中修改 __construct 方法123456public $user;public function __construct(User $user)&#123; $this-&gt;user = $user;&#125; 3、修改 listener 文件1234567891011121314class SendWelcomeEmail&#123; public $mailer; public function __construct(UserMailer $mailer) &#123; $this-&gt;mailer = $mailer; &#125; public function handle(EventName $event) &#123; $this-&gt;mailer-&gt;welcome($event-&gt;user); &#125;&#125; 4、在 App 下创建 Mailer\\Mailer.php （注意namespace是 App\\Mailer ）123456public function sendTo($user, $subject, $view, $data=[])&#123; Mail::queue($view, $data, function($message) use ($user, $subject)&#123; $message-&gt;to($user-&gt;email)-&gt;subject($subject); &#125;);&#125; 5、因为所有邮件发送都会调用到源生的 Mail，所以将 Mailer 作为父类继承：创建一个 Mailer\\UserMailer（namespace为 App\\UserMailer）1234567891011class UserMailer extends Mailer&#123; public function welcome($user) &#123; $subject = \"Welcome to xxx\"; $view = \"emails.welcome\"; //创建views\\emails\\welcome.blade.php $data = ['name' =&gt; $user-&gt;name, 'toekn' =&gt; $user-&gt;token]; //token为confirmed_code $this -&gt; sendTo($user, $subject, $view, $data); &#125;&#125; 集成 SendCloud 服务1、配置 mail.php1'from' =&gt; ['address' =&gt; '发送email的邮箱', 'name' =&gt; '名字'] 2、配置 .env12SENDCLOUD_API_USER= SendCloud 上的 API_USERSENDCLOUD_API_KEY= SendCloud 上的 API_KEY 3、修改 Mailer\\Mailer.php1234567891011121314151617181920212223242526protected $url = 'http://api.sendcloud.net/apiv2/mail/sendtemplate'; //一定要加这一行public function sendTo($user, $subject, $view, $data=[])&#123; $vars = json_encode(['to' =&gt; [$user-&gt;email], 'sub' =&gt; $data]); $param = [ 'apiUser' =&gt; env('SENDCLOUD_API_USER'), # 使用api_user和api_key进行验证 'apiKey' =&gt; env('SENDCLOUD_API_KEY'), 'from' =&gt; config('mail')['from']['address'], # 发信人，用正确邮件地址替代 'fromName' =&gt; config('mail')['from']['name'], 'xsmtpapi' =&gt; $vars, 'subject' =&gt; $subject, 'templateInvokeName' =&gt; $view, 'respEmailId' =&gt; 'true' ]; $sendData = http_build_query($param); $options = [ 'http' =&gt; [ 'method' =&gt; 'POST', 'header' =&gt; 'Content-Type: application/x-www-form-urlencoded', 'content' =&gt; $sendData ]]; $context = stream_context_create($options); return file_get_contents($this-&gt;url, FILE_TEXT, $context);&#125; 4、修改 Mailer\\UserMailer.php1234567public function welcome($user)&#123; $subject = '邮箱确认'; //必须跟SendCloud上的邮件标题一样 $view = 'welcome'; //必须跟SendCloud上的调用名称一样 $data = ['%name%' =&gt; [$user-&gt;name],'%token%' =&gt; [str_random(40)]]; //SendCloud将%var%作为参数 $this-&gt;sendTo($user, $subject, $view, $data);&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"mail","slug":"mail","permalink":"https://nancelglap.github.io/tags/mail/"},{"name":"SendCloud","slug":"SendCloud","permalink":"https://nancelglap.github.io/tags/SendCloud/"}]},{"title":"PHP单元测试","slug":"PHP单元测试","date":"2017-06-09T12:01:58.000Z","updated":"2017-06-19T11:04:39.000Z","comments":true,"path":"2017/06/09/PHP单元测试/","link":"","permalink":"https://nancelglap.github.io/2017/06/09/PHP单元测试/","excerpt":"与php单元测试相关内容","text":"与php单元测试相关内容 laravel下创建一个简单的单元测试 1、在 tests\\Unit 目录下创建一个如 NameTest 的文件2、让类继承于 phpUnit 类，引用被测试的类12345678910111213141516/*** 用于用于测试App\\Product.php中的Product类中的name()方法是否返回'Mac'*/use App\\ClassName;class NameTest extends \\PHPUnit_Framework_TestCase&#123; /** @test */ //一定要声明为test，并且按照此行格式写 public function a_product_has_a_name () //声明函数名用`_`分开 &#123; $product = new Product('Mac'); $this-&gt;assertEquals('Mac', $product-&gt;name()); &#125;&#125; 3、运行测试 vendor/bin/phpunit 或 phpunit，如果只运行单个测试文件1phpunit --filter=NameTest 4、解决单元测试代码重用问题：加入 setUp 函数（在每个函数执行之前都会先执行 setUp 函数内的内容）1234public function setUp()&#123; ...;&#125; Laravel测试Eloquent Model 1、在 tests/Unit 下创建文件，并继承laravel的测试类TestCase1234567891011121314151617use Illuminate\\Foundation\\Testing\\DatabaseTransactions;class NameTest extends TestCase&#123; use DatabaseTransactions; //防止每次测试都产生数据 public function test_method() &#123; factory(Article::class, 3)-&gt;create(); //先在ModelFactory加入生成数据代码 factory(Article::class)-&gt;create(['reads' =&gt; 10]); //增加一条信息，read字段为10 $mostPopular = factory(Article::class)-&gt;create(['reads' =&gt; '20']); $articles = Article::trending(); //该方法按reads大小降序排列文章 $this-&gt;assertEquals($mostPopular-&gt;id, $articles-&gt;first()-&gt;id); &#125;&#125; 2、在 model 中编写相应方法（用到 queryScope ）1234public function scopeTrending($query)&#123; return $query-&gt;orderBy('reads', 'desc')-&gt;get();&#125;","categories":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/categories/php/"}],"tags":[{"name":"phpunit","slug":"phpunit","permalink":"https://nancelglap.github.io/tags/phpunit/"},{"name":"test","slug":"test","permalink":"https://nancelglap.github.io/tags/test/"},{"name":"debug","slug":"debug","permalink":"https://nancelglap.github.io/tags/debug/"}]},{"title":"php命名空间和自动加载","slug":"php命名空间和自动加载","date":"2017-06-08T08:33:09.000Z","updated":"2017-06-19T11:04:43.000Z","comments":true,"path":"2017/06/08/php命名空间和自动加载/","link":"","permalink":"https://nancelglap.github.io/2017/06/08/php命名空间和自动加载/","excerpt":"解决包含 Class 要用多个 require 问题","text":"解决包含 Class 要用多个 require 问题 1、在项目目录下创建 composer.json 文件，加入以下内容1234567&#123; \"autoload\":&#123; \"psr-4\":&#123; \"namespace的名\\\\\":\"实际路径名/\" &#125; &#125;&#125; 2、在要被加载的文件加入1namespace namespace的名; 3、生成 autoload 文件并加载1composer dump-autoload 4、在加载其他文件的文件中加入123require 'vendor/autoload.php';use namespace的名\\Class文件名;","categories":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/tags/php/"},{"name":"namespace","slug":"namespace","permalink":"https://nancelglap.github.io/tags/namespace/"},{"name":"require","slug":"require","permalink":"https://nancelglap.github.io/tags/require/"},{"name":"autoload","slug":"autoload","permalink":"https://nancelglap.github.io/tags/autoload/"}]},{"title":"vim常用操作","slug":"vim常用操作","date":"2017-06-07T03:53:47.000Z","updated":"2017-06-19T11:05:17.000Z","comments":true,"path":"2017/06/07/vim常用操作/","link":"","permalink":"https://nancelglap.github.io/2017/06/07/vim常用操作/","excerpt":"","text":"插入 在当前位置前插入：i在当前行首插入：I在当前位置后插入：a在当前行尾插入：A在当前行之后插入一行：o在当前行之前插入一行：O 跳转 跳到到行尾：$跳到到行首：0跳到n行：nG跳到文本末尾：G向下翻页：Control + f向上翻页：Control + b下一个单词：w上一个单词：b下一行行首：+上一行行首：- 删除 删除到行首：d$删除到行尾：D删除光标字符：x删除光标后的单词：de 复制粘贴 复制当前行：yy复制从光标到行尾的内容：y$复制从光标到行首的内容：y^粘贴到光标右侧：p粘贴到光标左侧：P 查找 查找：/content（ n 跳到下一个内容 ）","categories":[{"name":"vim","slug":"vim","permalink":"https://nancelglap.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://nancelglap.github.io/tags/vim/"}]},{"title":"Model Factory","slug":"Model-Factory","date":"2017-06-06T01:24:32.000Z","updated":"2017-06-19T11:04:29.000Z","comments":true,"path":"2017/06/06/Model-Factory/","link":"","permalink":"https://nancelglap.github.io/2017/06/06/Model-Factory/","excerpt":"","text":"运用 Model Factory 本地化并且创建数据库数据 可生成的字段：https://github.com/fzaninotto/Faker 一、用tinker生成 1、在 database\\factories 中创建或使用文件，根据上述网址添加字段2、本地化（使用中文创建数据）：修改 App\\Providers\\AppServiceProvider.php 的 boot 方法123456789101112use Faker\\Generator as FakerGenerator;use Faker\\Factory as FakerFacotry;...public function boot() &#123; //singleton方法：启动laravel项目的时候，该方法将写在里面的类返回单例模式给Laravel全局使用 $this-&gt;app-&gt;singleton(FakerGenerator::class, Function() &#123; return FakerFacotry::create('zh_CN'); &#125;);&#125; 3、使用12345php artisan tinker //进入tinkernamespace App;factory(ModelName::class, num)-&gt;make() //num为要生成的数据个数，make方法只生成数据不加入数据库factory(ModelName::class, num)-&gt;create() //num为要生成的数据个数，create方法将生成的数据加入数据库 二、用DB Seed生成 1、生成 seeder 文件1php artisan make:seeder FileName 2、改 database\\seeds\\FileName 中的 run 方法1234public function run()&#123; factory(\\App\\ModelName::class, num)-&gt;create(); //num为要创建的数据条数&#125; 3、因为执行 php artisan db:seed 默认执行 DatabaseSeeder 文件，故要在该文件加入以下内容1$this-&gt;call(FileName::class); 4、执行php artisan db:seed 如果要生成一个另一个表的数据1、在ModelFactory中增加1234567891011121314$factory-&gt;define(App\\ModelName::class, function (Faker\\Generator $faker) &#123; static $password; return [ //'name' =&gt; $faker-&gt;name, //'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, //'password' =&gt; $password ?: $password = bcrypt('secret'), //'remember_token' =&gt; str_random(10), 'title' =&gt; $faker-&gt;sentence, 'intro' =&gt; $faker-&gt;paragraph, 'time' =&gt; $faker-&gt;dateTime, 'image' =&gt; $faker-&gt;imageUrl, ];&#125;); 2、在DatabaseSeeder 文件加入以下内容1$this-&gt;call(FileName::class);","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"database","slug":"database","permalink":"https://nancelglap.github.io/tags/database/"},{"name":"data","slug":"data","permalink":"https://nancelglap.github.io/tags/data/"}]},{"title":"Laravel Event","slug":"Laravel-Event","date":"2017-06-04T03:00:56.000Z","updated":"2017-06-19T11:04:23.000Z","comments":true,"path":"2017/06/04/Laravel-Event/","link":"","permalink":"https://nancelglap.github.io/2017/06/04/Laravel-Event/","excerpt":"当触发某个事件时自动完成一系列的操作","text":"当触发某个事件时自动完成一系列的操作 1、如果要修改新 Event 的名称，修改 EventProvider.php 中的 listen 数组12345678910111213protected $listen = [ 'App\\Events\\NewEventName1' =&gt; [ 'App\\Listeners1\\ListenersName1', 'App\\Listeners1\\ListenersName2', ... ], 'App\\Events\\NewEventName2' =&gt; [ 'App\\Listeners2\\ListenersName1', 'App\\Listeners2\\ListenersName2', ... ], ...]; 2、到 listener 监听文件中的 handle 函数编写当事件触发时要执行的操作1234public function handle(EventName $event)&#123; ...&#125; 3、触发事件1event(new \\App\\Events\\EventName()); 引用功能模块 1、引入模块功能，修改 __construct() 函数1234567class ListenerName&#123; public function __construct(Filesystem $filesystem) &#123; $this-&gt;filesystem = $filesystem; &#125;&#125; 2、编写处理操作，修改 handle 函数1234public function handle(EventName $event)&#123; $this-&gt;filesystem-&gt;method();&#125; 示例：触发用户事件 1、更改 Event 文件中的 __construct() 函数123456789101112&lt;?php...class EventName extends Event&#123; ... public $user; public function __construct(User $user) //接收事件发生时传来的用户数据参数 &#123; $this-&gt;user = $user; &#125;&#125; 2、更改 listener 文件1234public function handle(EventName $event)&#123; $event-&gt;user-&gt;name; //由Event文件传来的数据，引用用户名&#125; 3、在 Route 触发事件12$user = \\App\\User::find(1); event(new \\App\\Events\\EventName($user)); //在Event文件编写了__construct()，所以传用户数据进去能进行以后操作 用event优化用户注册 1、在 model 中定义方法取代 modelName::create()1234567public static function register(array $array) //array为用户数据构成的数组&#123; $user = static::create($array); event(new EventName($user)); //触发事件完成listener中handle方法内容 return $user;&#125; 2、在 event 文件中修改 __construct 方法123456public $user;public function __construct(User $user)&#123; $this-&gt;user = $user;&#125; 3、在 listener 文件中修改 handle 方法1234public function handle(EventName $event)&#123; return $event-&gt;user-&gt;email;&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"Event","slug":"Event","permalink":"https://nancelglap.github.io/tags/Event/"}]},{"title":"Laravel 向 Container 添加自定义类","slug":"Laravel-向-Container-添加自定义类","date":"2017-06-03T02:10:52.000Z","updated":"2017-06-19T11:03:58.000Z","comments":true,"path":"2017/06/03/Laravel-向-Container-添加自定义类/","link":"","permalink":"https://nancelglap.github.io/2017/06/03/Laravel-向-Container-添加自定义类/","excerpt":"","text":"1、通过 php artisan make:provider ProviderName 创建一个 provider 2、在 app 创建一个新的目录，目录创建新的类文件123456789&lt;?phpnamespace App\\directoryNameclass className &#123; public function fname () &#123; ...; &#125;&#125; 3、在新建的 provider 中的 register 函数绑定全局自己自定义的类123456public function register ()&#123; $this-&gt;app-&gt;bind('name', function() &#123; return new ClassName(); &#125;);&#125; 4、（放入IOC中，可以在任何地方使用 app(&#39;name&#39;)实现 3 中的类）在 config\\app.php 的 provider 数组中增加新建的 provider1234'providers' =&gt; [ ... App\\Providers\\NewServiceProvider::class; //NewServiceProvider为新建的provider文件名] 5、在 laravel 的 任何地方可以调用类已经类里面的方法（app 内的参数名必须是在新 provider 的 register 函数中绑定的通过 app 绑定的名字）12345//在web.php中调用Route::get('/', function () &#123; $var = app('name'); //实例化了一个ClassName对象 $var-&gt;fname();&#125;)","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"}]},{"title":"Http状态码","slug":"Http状态码","date":"2017-06-01T03:05:30.000Z","updated":"2017-06-19T11:03:16.000Z","comments":true,"path":"2017/06/01/Http状态码/","link":"","permalink":"https://nancelglap.github.io/2017/06/01/Http状态码/","excerpt":"Http常用状态码","text":"Http常用状态码 2**：成功处理请求的状态代码 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3**：要完成请求，需要进一步操作 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4**：请求错误 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5**：服务器错误 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","categories":[{"name":"Http","slug":"Http","permalink":"https://nancelglap.github.io/categories/Http/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://nancelglap.github.io/tags/Http/"},{"name":"project","slug":"project","permalink":"https://nancelglap.github.io/tags/project/"},{"name":"status code","slug":"status-code","permalink":"https://nancelglap.github.io/tags/status-code/"}]},{"title":"","slug":"PhpStorm","date":"2017-05-30T13:32:47.000Z","updated":"2017-06-19T11:05:01.000Z","comments":true,"path":"2017/05/30/PhpStorm/","link":"","permalink":"https://nancelglap.github.io/2017/05/30/PhpStorm/","excerpt":"title: PhpStormdate: 2017-05-30 21:32:47tags: ide PhpStormcategories: phpstorm PhpStorm快捷键等","text":"title: PhpStormdate: 2017-05-30 21:32:47tags: ide PhpStormcategories: phpstorm PhpStorm快捷键等 一、通用类1、*Command + Shift + A：搜索配置项（搜索keymap改快捷键）2、Command + P：文件之间跳转3、Command + B：查看类的关系4、Command + Control + S：查看类里面的方法等 二、编辑类1、Command + Delete：删除光标行2、Shift + Delete：删除光标后面所有内容3、Control + Delete：删除光标前面所有内容4、Control + Shift + Delete：删除光标所在单词5、Command + Shift+ D：复制当前行到下一行6、Command + D：逐个选相同的词（多点编辑）7、Command + Control + D：全选相同的词（多点编辑）8、Command + G：选中下一个光标所在一样的词9、Command + Shift + G：选中上一个光标所在一样的词","categories":[],"tags":[]},{"title":"你站住项目进度","slug":"你站住项目进度","date":"2017-05-20T13:00:50.000Z","updated":"2017-06-11T14:56:44.000Z","comments":true,"path":"2017/05/20/你站住项目进度/","link":"","permalink":"https://nancelglap.github.io/2017/05/20/你站住项目进度/","excerpt":"你站住后台项目进度记录","text":"你站住后台项目进度记录5.20 已完成1、初步了解微信小程序语法内容2、了解JWT替代原session完成登录机制3、写完了用户登录的AuthController 待完成1、各个接口编写2、数据库的创建3、继续了解小程序语法，做简单的测试4、服务器的部署，http转https 5.23 已完成1、完成JWT替代原session完成登录机制2、了解JWT整个验证流程 待完成1、其他接口的编写2、了解小程序语法，做简单测试3、服务器的部署，http转https 5.24 已完成1、完成JWT中间件验证2、写完几个api接口 待完成1、用户编辑接口（点击删除删除信息）2、了解小程序语法，做简单测试3、服务器的部署，http转https 5.25 已完成1、将 token 放入 header 中完成 jwt 中间件的验证 待完成1、其他接口编写2、用户编辑接口3、了解小程序语法，做简单测试4、买服务器，服务器部署，http转https","categories":[],"tags":[{"name":"ustopmoving","slug":"ustopmoving","permalink":"https://nancelglap.github.io/tags/ustopmoving/"},{"name":"你站住","slug":"你站住","permalink":"https://nancelglap.github.io/tags/你站住/"},{"name":"loading","slug":"loading","permalink":"https://nancelglap.github.io/tags/loading/"}]},{"title":"微信小程序相关文档","slug":"微信小程序相关文档","date":"2017-05-20T01:58:03.000Z","updated":"2017-06-19T11:02:26.000Z","comments":true,"path":"2017/05/20/微信小程序相关文档/","link":"","permalink":"https://nancelglap.github.io/2017/05/20/微信小程序相关文档/","excerpt":"与小程序相关网站","text":"与小程序相关网站 文档类 微信小程序官方文档：https://mp.weixin.qq.com/debug/wxadoc/dev/&lt;简书&gt;小程序开发专栏：http://www.jianshu.com/c/dfdc2bbd1315W3Cschool文档：http://www.w3cschool.cn/weixinapp/weixinapp-app.html 各功能实现 功能合集：http://weixin1024.cn/forum.php?mod=viewthread&amp;tid=1027&amp;extra=page%3D1 小程序账号申请 &lt;有道云笔记&gt;：http://note.youdao.com/share/?id=744b94b02c28321c8f930e1f495624e5&amp;type=note#/ 项目案例 项目列表：http://blog.csdn.net/qq137722697/article/details/52988719小黄车小程序：http://www.jianshu.com/p/68e3b8927a77项目：http://www.cnblogs.com/tuyile006/p/6268961.html 登录注册实现 维护用户登录态可以用JWT完成1、注意设置JWT过去时间123456$payload = [ 'email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password')， 'exp' =&gt; time()+60*60 //设置token过期时间 ];$token = JWTAuth::attempt($payload) &lt;简书&gt;后台登录文章：http://www.jianshu.com/p/6096e8522c4c注册登录实现：http://blog.csdn.net/qq_19558705/article/details/65935818?utm_source=gold_browser_extension http站点转https站点 在nginx服务器下配置和安装阿里云购买的SSL证书：http://sanwen.net/a/hmdfcoo.html request请求(前端后台数据交互) request请求：http://blog.csdn.net/qq_19558705/article/details/60783448","categories":[{"name":"Wechat","slug":"Wechat","permalink":"https://nancelglap.github.io/categories/Wechat/"}],"tags":[{"name":"Wechat","slug":"Wechat","permalink":"https://nancelglap.github.io/tags/Wechat/"},{"name":"Mini Programes","slug":"Mini-Programes","permalink":"https://nancelglap.github.io/tags/Mini-Programes/"}]},{"title":"PHP 面向对象编程","slug":"PHP-面向对象编程","date":"2017-05-14T08:19:52.000Z","updated":"2017-06-19T11:04:47.000Z","comments":true,"path":"2017/05/14/PHP-面向对象编程/","link":"","permalink":"https://nancelglap.github.io/2017/05/14/PHP-面向对象编程/","excerpt":"PHP 面向对象相关","text":"PHP 面向对象相关 final关键字 final关键字只能用来标记类和方法1、final标记的类不能被继承2、final标记的方法不能被子类覆盖，是最终版本 __call()方法 当调用对象内部方法不存在时自动调用，第一个参数为不存在的函数名，第二个参数把这个方法里的参数作为数组形式传进来1234567891011121314class test &#123; function __call($function_name, $args) &#123; echo $function_name; print_r($args); &#125;&#125;$test = new test();$test -&gt; hello('you', 'are', 'sb');//程序不会退出继续执行echo \"11111\"; 上述的输出结果为hello Array([0] =&gt; you [1] =&gt; are [2] =&gt; sb) static 和 const 1、static（1）static的成员在类第一次被加载的时候分配空间，被实例化的对象共用，属于类，无法用$this访问（2）在类内部访问static成员1self::$变量名 //有'$' （3）在类外部访问static成员1ClassName::$变量名 //有'$' 2、const（1）const为在类内部定义常量的方法（2）在类内部访问const属性1self::变量名 //没有'$' （3）在类外部访问const属性1ClassName::变量名 //没有'$' trait 解决代码重用问题1234567891011121314151617trait NameTrait &#123; public function fun() &#123; var_dump('something'); &#125;&#125;class className1 &#123; use NameTrait;&#125;class className2 &#123; use NameTrait;&#125;new ClassName1()-&gt;fun();new ClassName2()-&gt;fun(); public、protected、private protected方法不能直接在继承的类的对象中访问，要在继承类中重新定义一个方法里面调用 $this-&gt;method1、public声明的成员可以在任何位置调用2、protected声明的成员只有在类的内部还有子类中可以调用3、private声明的成员只有在类的内部可以调用4、调用方法为12$this -&gt; name; //调用成员属性$this -&gt; function(); //调用成员方法 注：子类的权限只能大于等于父类 接口（Interface） 定义：类里面所有的方法都为抽象方法的类称为接口1、接口内不能声明变量，但可以声明常量constant2、所有成员都是public权限3、声明接口使用关键字interface123456789101112&lt;?phpinterface One &#123; //定义一个常量 const constant = 'constant value'; //定义一个抽象方法\"fun1\" public function fun1(); //定义了抽象方法\"fun2\" public function fun2();&#125;?&gt; 4、定义接口的子类实现接口中全部抽象方法使用关键字implements123456789101112&lt;?phpclass Three implements One &#123; function fun1() &#123; ... &#125; function fun2() &#123; ... &#125;&#125;&#125;?&gt; 5、子类必须实现所有的抽象方法才能被实例化6、一个类可以实现多个接口12345&lt;?phpclass Four implements interface1, interface2, ... &#123; //必须把所有接口中的方法都实现才可以实例化对象&#125;?&gt; 7、在继承一个类的同时实现多个接口，先继承再实现123456&lt;?phpclass Four extends ClassName1 implements interface1, interface2, ... &#123; //所有接口中的方法都要实现才可以实例化对象 ...&#125;?&gt; 面向接口编程 在需要用到类作为参数的方法中将接口作为参数，过后传参数只需要传一个实现的接口的对象就可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** 创建一个接口*/interface hello &#123; public function fun1($message);&#125;/*** 实现接口*/class class1 implements hello &#123; public function show($message) &#123; return $message; &#125;&#125;/*** 实现接口*/class class2 implements hello &#123; public function show($message) &#123; return $message; &#125;&#125;/*** 创建一个类*/class Controller &#123; protected $hello; //参数为接口 public function __construct(hello $hello) &#123; $this-&gt;hello = $hello; &#125; public function show() &#123; $message = \"Nancelglap\"; $this-&gt;hello-&gt;show($message); &#125;&#125;//当要切换类的时候就不用再更改construct方法中的hello接口，直接改实例化对象的类名$demo = new Controller(new class1);$demo -&gt; show();$demo = new Controller(new class2);$demo -&gt; show();","categories":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/tags/php/"},{"name":"OOP","slug":"OOP","permalink":"https://nancelglap.github.io/tags/OOP/"},{"name":"面向对象","slug":"面向对象","permalink":"https://nancelglap.github.io/tags/面向对象/"}]},{"title":"Git相关","slug":"git相关操作","date":"2017-05-13T07:33:41.000Z","updated":"2017-06-19T11:03:07.000Z","comments":true,"path":"2017/05/13/git相关操作/","link":"","permalink":"https://nancelglap.github.io/2017/05/13/git相关操作/","excerpt":"与git相关的内容","text":"与git相关的内容 Git配置 一、增加配置项1git config --global/system 配置名 \"值\" 1、如果只在当前项目增加配置 （1）切换到当前项目 （2）git config 配置名 &quot;值&quot;1、--global 将配置放到home目录下（~/.gitconfig）2、--system 将配置放到/etc/.gitconfig中3、--local 将配置放到每一个项目中4、常用配置有user.name、user.eamil，color.ui，core.editor 二、查看配置项1git config 配置名 Git基本工作流程 1、查看修改状态1git status 2、初始化当前目录1git init 3、如果有文件修改，先加入 staged area1git add 文件名 / git add . 4、更新提交到 staged area 的内容（只修改没执行git add的不会更新）1git commit -m \"更新描述\" 5、查看 commit 的内容1git log //按q退出 .gitignore 将上传的文件内容加入此文件中，更新会忽略此文件1、用PhpStorm编辑的，加入.idea2、用Mac系统的，加入.DS_Store Git分支 想修改之前的bug，但是又不想将还没写完的新内容提交上去等 1、查看分支1git branch 2、回到某个文件提交之前的内容1git checkout -- app/Http/routes.php 3、创建分支、切换到分支1234git branch BranchNamegit checkout BranchNamegit checkout -b BranchName //创建分支并切换到该分支 4、合并分支（在matser下操作）1git merge BranchName 5、删除分支1git branch -d BranchName Git分支merge冲突的修改 当master和分支中同个文件修改存在冲突，则需要处理 必须是两个分支的文件都已经git add和git commit -m&quot;content&quot;操作1、切换到master，执行 git merge BranchName，会报有冲突 2、进入冲突文件，删掉不要的冲突内容，然后执行1234git add fileNamegit commit//进入到vim后保存退出 Git设置快捷键 1git config --global alias.s status //设置后用 git s 替代 git status 全局设置快捷键1234vim ~/.zshrc//加入以下内容alias gs=\"git status\" //设置后用 gs 替代 git status Git stash 运用场景：如果在一个分支上开发一个模块同时，又要回到master中改bug，执行git stash可以将分支上的修改先放到一边，回到master中更新内容 12345git stash list //查看之前拿开的内容git stash apply stash@&#123;num&#125; //恢复相应num的内容git stash pop //回复内容并删除，省略掉drop步骤git stash drop //删掉list中拿开的内容` 作用：1、将在 master 中修改好的合并到未完成的分支上2、master 未融合未完成的分支的内容 过程一、修改 master 上的内容，合并到分支上，但分支内容不合并到 master 上 1、修改分支的内容 2、在分支执行 git stash 3、在 master 分支中更改内容，改完之后gaa、gc “content” 4、回到 master 分支，执行git merge BranchName 合并 二、继续完成分支上的内容，完成后合并到 master 1、git checkout BranchName切换到分支 2、git stash apply 或 git stash pop 拿回原来拿开的问题 3、继续写分支内容，写完然后 gaa、gc “content” 4、回到 master 分支，执行git merge BranchName 合并 本地更新代码后更新到github上 123git add .git commit -m \"描述内容\"git push origin master 本地更新到远程服务器上 1234567git add .git commit -m \"描述内容\" //只有更改文件的目录才会改描述内容git push//切到服务器，进入项目目录cd /var/www/laravel/git pull","categories":[{"name":"Git","slug":"Git","permalink":"https://nancelglap.github.io/categories/Git/"}],"tags":[{"name":"server","slug":"server","permalink":"https://nancelglap.github.io/tags/server/"},{"name":"git","slug":"git","permalink":"https://nancelglap.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://nancelglap.github.io/tags/github/"}]},{"title":"VPS上配置和域名解析","slug":"VPS上配置和域名解析","date":"2017-05-13T07:17:39.000Z","updated":"2017-06-19T11:05:23.000Z","comments":true,"path":"2017/05/13/VPS上配置和域名解析/","link":"","permalink":"https://nancelglap.github.io/2017/05/13/VPS上配置和域名解析/","excerpt":"","text":"1、更改/etc/nginx/sites-avaliable/default修改server中的server_name1server_name elective.com www.elective.com; 2、重启nginx使配置文件生效1sudo service nginx restart 3、解析域名（1）复制IP地址（2）打开dnspod进行域名解析https://www.dnspod.cn/（3）将记录类型为A的记录值修改为IP地址（4）复制上方的DNS修改内容，到godaddy网站https://sg.godaddy.com/zh?isc=gennbacn29&amp;countrview=1&amp;currencytype=CNY&amp;mkwid=WFSMCUdy&amp;cvosrc=ppc.baidu（5）到mydomain里修改Nameservers，nameservers type改为Custom，两个Nameserver内容粘贴刚才复制的两条内容","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"VPS","slug":"VPS","permalink":"https://nancelglap.github.io/tags/VPS/"},{"name":"server","slug":"server","permalink":"https://nancelglap.github.io/tags/server/"},{"name":"Domain","slug":"Domain","permalink":"https://nancelglap.github.io/tags/Domain/"}]},{"title":"安装LEMP环境","slug":"安装LEMP环境","date":"2017-05-12T12:04:53.000Z","updated":"2017-06-19T11:02:17.000Z","comments":true,"path":"2017/05/12/安装LEMP环境/","link":"","permalink":"https://nancelglap.github.io/2017/05/12/安装LEMP环境/","excerpt":"在mac/linux上安装LEMP环境","text":"在mac/linux上安装LEMP环境 购买远程服务器VPS教程：https://www.laravist.com/series/deploy-laravel-app-on-vps/episodes/1 1、先登录远程服务器1ssh root@Ip Address 查看服务器（选择ubuntu14）1lsb_release -a 2、更新apt-get1sudo apt-get update 3、安装语言包避免系统语言引起的冲突问题1sudo apt-get install -y language-pack-en-base 4、设置语言1locale-gen en_US.UTF-8 5、安装常用工具1sudo apt-get install -y vim htop git //htop查看机器cup等用了多，git用于部署项目 6、安装php7（通过添加ppa方式安装）12345678910sudo apt-get install -y software-properties-commonsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/phpsudo apt-get updateapt-cache search php7.1 //查找php7.1包sudo apt-get install -y php7.1php -v //查看版本sudo apt-get install -y php7.1-mysqlsudo apt-get install -y php7.1-fpmsudo apt-get install -y php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring 7、安装mysql1sudo apt-get install mysql-server-5.6 8、安装nginx1sudo apt-get install nginx 9、阿里云服务器用ip地址访问http://blog.csdn.net/qq_27211105/article/details/55668997增加安全组配置规则1、网卡类型：公网2、规则方向：入方向3、授权策略：允许4、协议类型：TCP5、端口范围：80/806、授权类型：地址段访问7、授权对象：0.0.0.0/08、优先级：1","categories":[{"name":"server","slug":"server","permalink":"https://nancelglap.github.io/categories/server/"}],"tags":[{"name":"php","slug":"php","permalink":"https://nancelglap.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://nancelglap.github.io/tags/mysql/"},{"name":"nginx","slug":"nginx","permalink":"https://nancelglap.github.io/tags/nginx/"}]},{"title":"在购买的VPS上配置环境运行Laravel","slug":"在购买的VPS上配置环境运行Laravel","date":"2017-05-12T12:01:26.000Z","updated":"2017-06-19T11:02:09.000Z","comments":true,"path":"2017/05/12/在购买的VPS上配置环境运行Laravel/","link":"","permalink":"https://nancelglap.github.io/2017/05/12/在购买的VPS上配置环境运行Laravel/","excerpt":"php + nginx + mysql","text":"php + nginx + mysql 购买VPS服务器地址：https://www.vultr.com/ 1、先登录远程服务器1ssh root@Ip Address 2、配置php（修改php.ini）1sudo vim /etc/php/7.1/fpm/php.ini 将cgi.fix_pathinfo=1去掉注释，并改为1cgi.fix_pathinfo=0 3、配置php-fpm（可以不改）1vim /etc/php/7.1/fpm/pool.d/www.conf （可以不改）改listen = /run/php/php7.1-fpm.sock为1listen = /var/run/php7.1-fpm.sock 4、配置nginx的default文件1vim /etc/nginx/sites-avaliable/default 改server内容1234567891011server&#123; root /var/www/laravel/public; //自定义根目录，laravel为创建的项目 index index.php index.html index.htm; //服务器首先找public目录下的index.php server_name localhost; //如果有注册域名就改为自己的域名 //修改location里面的try_files location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125;&#125; 直接增加location ~ \\.php$12345678location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php7.1-fpm.sock; //如果php-fpm配置改了就要改成相应的listen值 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 5、创建根目录根据/etc/nginx/sites-avaliable/default中server内容中的root创建根目录1mkdir /var/www //根据自定义的路径创建 6、改根目录拥有者1sudo chown -R www-data:www-data /var/www //www-data默认为nginx的用户名和用户组 7、在服务器根目录下创建Laravel项目并上传到github 通过git拉取实现 （1）回到本地创建Laravel项目12laravel new ProjectName //如果没将laravel加入全局变量就用composercomposer create-project laravel/laravel ProjectName （2）在github创建新项目 （3）上传项目先在服务器上创建ssh key，后加入到github的ssh key中1ssh-keygen -t rsa -C “github邮箱” 12345678cd ProjectName/git initgit add .git commit -m \"更改描述\"git remote add origin git@github.com:UserName/ProjectName.git //UserName为自己的github用户名，ProjectName为在github创建的项目名git push -u origin master （4）刷新github就可看见代码 8、用git将github上的代码克隆到服务器开发的话如果有更新就先将代码推送到gtihub，再从服务器拉取代码123git pull //更新github上的代码//ssh登录远程服务器后，切到www目录git clone git项目地址 更新项目 本地更新到服务器上 1234567git add .git commit -m \"描述内容\" //只有更改文件的目录才会改描述内容git push//切到服务器，进入项目目录cd /var/www/laravel/git pull 本地更新到github上 123git add .git commit -m \"描述内容\"git push origin master 9、安装composer 地址www.getcomposer.org/download/ （1）全局使用composer1mv composer.phar /usr/local/bin/composer （2）进入到项目目录123cd /var/www/ProjectName/composer install --no-dev 如果composer install --no-dev出现问题，因为没安装zip、和unzip 10、创建.env文件并修改权限123cd /var/www/ProjectName/vim .env （1）加入所有配置项，修改以下(未修改的未列出)123456APP_ENV = productionAPP_DEBUG = falseDB_DATABASE = 数据库名DB_USERNAME = 数据库用户名DB_PASSWORD = 数据库用户密码 （2）修改权限1sudo chmod -R 775 storage/ 11、重载nginx，重启php-fpm，将项目目录给nginx用户123sudo service nginx reloadsudo service php7.1-fpm restartsudo chown -R www-data:www-data /var/www/ProjectName/","categories":[{"name":"server","slug":"server","permalink":"https://nancelglap.github.io/categories/server/"},{"name":"laravel","slug":"server/laravel","permalink":"https://nancelglap.github.io/categories/server/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"VPS","slug":"VPS","permalink":"https://nancelglap.github.io/tags/VPS/"},{"name":"server","slug":"server","permalink":"https://nancelglap.github.io/tags/server/"}]},{"title":"用户认证（Auth）","slug":"用户认证","date":"2017-05-10T14:12:12.000Z","updated":"2017-06-19T11:02:40.000Z","comments":true,"path":"2017/05/10/用户认证/","link":"","permalink":"https://nancelglap.github.io/2017/05/10/用户认证/","excerpt":"","text":"一、auth.php文件配置(修改auth验证的表) 在guards数组中的每一项都是一个角色，默认的有web和api两种，这就表示了当前有这两种角色会使用到认证系统。driver就是表示这个认证要怎么去保存用户状态，一般是保存在session中，provider就是告诉Laravel你的用户信息保存在哪一张表里面，driver就是告诉了要使用那种方式来操作数据库。1234567891011'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'token', 'provider' =&gt; 'users', ],], 二、具体运用 方法一：在Controller中增加middleware键值对当路由中使用了保护路由：&#39;middleware&#39; =&gt; &#39;auth&#39;，此路由需先经过路由的路径名为’/login’执行后才跳转到此路由执行可以对路由组使用此中间件，以下组内所有路由的访问都需先经过路由路径为’/login’的认证路由中的路径必须是根目录下的’/login’1234//如果路径前面再加任何的前缀就会出错'/admin/path'Route::get('/login', function() &#123; return view('auth.login'); &#125;) 1234567Route::group(['namespace'=&gt;'Admin', 'middleware'=&gt;'auth'], function()&#123; Route::get('admin/path1', 'UploadController@method1'); Route::get('admin/path2', 'UploadController@method2'); Route::get('admin/path3', 'UploadController@method3'); Route::get('admin/path4', 'UploadController@method4');&#125; 方法二：在控制器中增加构造方法__construct1234public function __construct()&#123; $this-&gt;middleware('auth');&#125; 补充返回经过JWTAuth认证后的实例123Route::get('/user', function (Request $request) &#123; return $request-&gt;user();&#125;)-&gt;middleware('jwt.api.auth');","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"middleware","slug":"middleware","permalink":"https://nancelglap.github.io/tags/middleware/"},{"name":"auth","slug":"auth","permalink":"https://nancelglap.github.io/tags/auth/"}]},{"title":"JWT + dingo","slug":"JWT-dingo","date":"2017-05-10T12:01:07.000Z","updated":"2017-06-19T11:42:32.000Z","comments":true,"path":"2017/05/10/JWT-dingo/","link":"","permalink":"https://nancelglap.github.io/2017/05/10/JWT-dingo/","excerpt":"laravel 中JWT(Json Web Token)和dingo的使用","text":"laravel 中JWT(Json Web Token)和dingo的使用 dingo dingo的作用给前端提供数据接口，前后端分离，返回JSON数据 一、安装 安装方法 1修改composer.json文件，执行composer update把最后一个版本的包加入项目中123\"required\": &#123; \"dingo/api\": \"1.0.*@dev\"&#125; 安装方法 2在命令行执行composer require命令1composer require dingo/api:1.0.x@dev 二、配置 1、打开config/app.php，注册service provider123'provider' =&gt; [ Dingo\\Api\\Provider\\LaravelServiceProvider::class] 2、如果想在配置文件中改变配置，使用下面Artisan命令发布配置文件1php artisan vendor:publish --provider=\"Dingo\\Api\\Provider\\LaravelServiceProvider\" 3、在.env中添加基础基础配置1234567API_STANDARDS_TREE = vndAPI_PREFIX = apiAPI_VERSION = v1API_DEBUG = true 三、使用 1、在routes\\api.php中123456789101112$api = app('Dingo\\Api\\Routing\\Router');$api -&gt; group(['namespace' =&gt; 'App\\Api\\Controllers'], function ($api) &#123; $api -&gt; get('login', 'Controllers@method'); ...; //只有在编辑信息，删除信息，创建信息的时候需要通过JWT验证客户端是否为登录的用户 $api -&gt; group(['middleware' =&gt; 'jwt.api.auth'], function ($api) &#123; $api -&gt; patch('/path/&#123;id&#125;', 'Controllers@update'); $api -&gt; post('/path/delete', 'Controllers@destory'); $api -&gt; post('/path/create', 'Controllers@store'); &#125;) &#125;) 2、创建Controller在\\App\\Api下创建Controller和Transformers目录在Controllers下创建BaseController.php作为被继承的基础模块1234567891011121314151617181920&lt;?php namespace App\\Api\\Controllers; use App\\Http\\Controllers\\Controller; use Dingo\\Api\\Routing\\Helpers; class BaseController extends Controller &#123; use Helpers; /**** * BaseController constructor. */ public function __construct() &#123; &#125; &#125; JWTAuth JWTAuth的作用在用户登录的时候根据要求的登录信息，token签发时间(iat)，token过期时间(exp)等进行base64编码得到的字符串叫做Payload（载荷）。之后用户的每次提交给服务器的行为都会带上token证明客户端用户身份 一、安装 安装方法 1使用Composer安装JWT扩展包：composer require tymon/jwt-auth 0.5.* 安装方法 2修改composer.json文件，执行composer update把最后一个版本的包加入项目中123\"required\": &#123; \"tymon/jwt-auth\":\"0.5.*\"&#125; 二、配置 1、在config/app.php中注册相应的Service Provider123'providers'=&gt;[ Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class, ] 2、注册jwt Facades1234'aliases'=&gt;[ 'JWTAuth'=&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class, 'JWTFactory'=&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class, ] 3、更新配置文件php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider&quot; 4、生成jwt.php文件中数组的secret键成对应的值php artisan jwt:generate 关联dingo和JWT 修改config/api.php的auth12345678'auth' =&gt; [ 'basic' =&gt; function($app)&#123; return new Dingo\\Api\\Auth\\Provider\\Basic($app['auth']); &#125;, 'jwt' =&gt; function($app)&#123; return new Dingo\\Api\\Auth\\Provider\\JWT($app['Tymon\\JWTAuth\\JWTAuth']); &#125;], 具体运用 1、添加中间件身份验证添加一个Middleware：GetUserFromTokenphp artisan make:middleware GetUserFromToken 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\\Http\\Middleware;use Closure;use JWTAuth;use Tymon\\JWTAuth\\Exceptions\\JWTException;use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException;use Tymon\\JWTAuth\\Exceptions\\TokenInvalidException;class GetUserFromToken&#123; public function handle($request, Closure $next) &#123; $auth = JWTAuth::parseToken(); if (! $token = $auth-&gt;setRequest($request)-&gt;getToken()) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_not_provided', 'data' =&gt; '', ]); &#125; try &#123; $user = $auth-&gt;authenticate($token); &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_expired', 'data' =&gt; '', ]); &#125; catch (JWTException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_invalid', 'data' =&gt; '', ]); &#125; if (! $user) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'user_not_found', 'data' =&gt; '', ]); &#125; //$this-&gt;events-&gt;fire('tymon.jwt.valid', $user); return $next($request); &#125;&#125; 2、在/app/hTTP/Kernel.php中routeMiddleware新增如下内容1234protected $routeMiddleware = [ ... 'jwt.api.auth' =&gt; \\App\\Http\\Middleware\\GetUserFromToken::class, //新增注册的中间件]; 3、验证表格更改如果要修改验证的用户表名，修改config/jwt.php&#39;user&#39; =&gt; &#39;App\\newName&#39;, 4、认证模块添加关注一下logout和register在AuthController中添加相应模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php namespace App\\Api\\Controllers; use App\\Client; use Illuminate\\Http\\Request; use JWTAuth; use Tymon\\JWTAuth\\Exceptions\\JWTException; use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException; use Tymon\\JWTAuth\\Exceptions\\TokenInvalidException; class AuthController extends BaseController &#123; /** * The authentication guard that should be used. * * @var string */ public function __construct() &#123; parent::__construct(); &#125; /** * @param Request $request * @return \\Illuminate\\Http\\JsonResponse */ public function authenticate(Request $request) &#123; $payload = [ 'user_email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password') ]; try &#123; if (!$token = JWTAuth::attempt($payload)) &#123; return response()-&gt;json(['error' =&gt; 'token_not_provided'], 401); &#125; &#125; catch (JWTException $e) &#123; return response()-&gt;json(['error' =&gt; '不能创建token'], 500); &#125; return response()-&gt;json(compact('token')); &#125; public function logout() &#123; JWTAuth::refresh(); //刷新token，注意区别于middleware的auth $arr = array ('LOG OUT'=&gt;\"SUCCESSED\"); return response()-&gt;json(compact('arr')); &#125; /** * @param Request $request */ public function register(Request $request) &#123; $newUser = [ 'user_email' =&gt; $request-&gt;get('email'), 'user_name' =&gt; $request-&gt;get('name'), 'password' =&gt; bcrypt($request-&gt;get('password')) ]; $user = Client::create($newUser); $token = JWTAuth::fromUser($user); return $token; &#125; /**** * 获取用户的信息 * @return \\Illuminate\\Http\\JsonResponse */ public function AuthenticatedUser() &#123; try &#123; if (!$user = JWTAuth::parseToken()-&gt;authenticate()) &#123; return response()-&gt;json(['user_not_found'], 404); &#125; &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json(['token_expired'], $e-&gt;getStatusCode()); &#125; catch (TokenInvalidException $e) &#123; return response()-&gt;json(['token_invalid'], $e-&gt;getStatusCode()); &#125; catch (JWTException $e) &#123; return response()-&gt;json(['token_absent'], $e-&gt;getStatusCode()); &#125; // the token is valid and we have found the user via the sub claim return response()-&gt;json(compact('user')); &#125; &#125; 5、使用Transformers隐藏返回api的数据1234567891011121314151617181920212223242526272829303132/*** app\\Api\\Transformers\\TestsTransformer.php*/&lt;?php namespace App\\Api\\Transformers; /**该类为dingo api封装好**/ use League\\Fractal\\TransformerAbstract; class TestsTransformer extends TransformerAbstract &#123; public function transform($lesson) &#123; //访问api的时候只会返回username, email, is_free 字段 return [ 'username' =&gt; $lesson['user_name'], 'email' =&gt; $lesson['user_email'], 'is_free' =&gt; (boolean) $lesson['free'] //将 0 1 转换为false 和 true ]; &#125; &#125; /*** Controller*/public function index()&#123; $comments = Comment::all(); return $this-&gt;collection($lessons, new TestsTransformer()); //new的类为Transformer的文件名&#125; 6、在路由中指定使用jwt.api.auth[&#39;middleware&#39; =&gt; &#39;jwt.api.auth&#39;]","categories":[{"name":"JWT Dingo","slug":"JWT-Dingo","permalink":"https://nancelglap.github.io/categories/JWT-Dingo/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"JWTAuth","slug":"JWTAuth","permalink":"https://nancelglap.github.io/tags/JWTAuth/"},{"name":"dingo","slug":"dingo","permalink":"https://nancelglap.github.io/tags/dingo/"}]},{"title":"Shell脚本相关","slug":"Shell脚本相关","date":"2017-05-10T08:39:54.000Z","updated":"2017-06-19T11:05:12.000Z","comments":true,"path":"2017/05/10/Shell脚本相关/","link":"","permalink":"https://nancelglap.github.io/2017/05/10/Shell脚本相关/","excerpt":"本文内容为bash操作相关","text":"本文内容为bash操作相关 参数 1、echo -e：包含转义序列的字符串形式输出2、echo -n：echo会将一个换行符追加到输出文本的尾部，可以使用-n忽略结尾换行符 其他 1、要输出感叹号的时候不要放在双引号内，如果要的话要加“\\”反斜杠2、查看PATH变量1echo $PATH 3、添加环境变量1export PATH=\"$PATH:/Users/...\" 4、获取字符串长度1length=$&#123;#var&#125;","categories":[{"name":"shell","slug":"shell","permalink":"https://nancelglap.github.io/categories/shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nancelglap.github.io/tags/Shell/"},{"name":"Terminal","slug":"Terminal","permalink":"https://nancelglap.github.io/tags/Terminal/"}]},{"title":"JWT的使用（中间件的坑）","slug":"创建token","date":"2017-05-06T13:49:41.000Z","updated":"2017-06-19T15:28:14.000Z","comments":true,"path":"2017/05/06/创建token/","link":"","permalink":"https://nancelglap.github.io/2017/05/06/创建token/","excerpt":"关于JWT的坑","text":"关于JWT的坑 原理 验证机制（需用到 GetUserFromToken 中间件）1、根据用户信息，还有后面加入的信息创建token，并将token保存在后台的缓存，可加入 $user[&#39;now&#39;]=time() 等信息 2、将token发给客户端，存在客户端的缓存中 3、需要验证的操作或者请求使用jwt中间件验证（将存在客户端缓存中的token取出并放在 header 中发回给后台） 4、请求通过jwt中间件将 header 中的 token 值与后台缓存的token对比，确认一致后继续进行下一步操作 使用注意事项 一、使用中间件jwt.api.auth参考资料：http://blog.csdn.net/qq_28666081/article/details/52188549 1、改 config/auth.php 中的 &#39;providers&#39; 数组中的 model 为相应要验证的model名12345'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\\Client::class, //Client为自己需要的model名 ], 2、model修改在创建的新 model 中加入以下1use Illuminate\\Foundation\\Auth\\User as Authenticatable; 修改新 model 继承的类123class Client extends Authenticatable &#123; //Authenticatale替换原来的model ....&#125; 二、其他2、修改 config/jwt.php 文件的 &#39;user&#39; 项，改为要验证的model3、config/jwt.php 中的 &#39;ttl&#39; 属性为token的有效时间，根据需要设置 创建Token 方法1：用户登录的时候返回123456789101112131415161718192021222324use JWTAuth;use Tymon\\JWTAuth\\Exceptions\\JWTException;class AuthenticateController extends Controller&#123; public function authenticate(Request $request) &#123; // grab credentials from the request $credentials = $request-&gt;only('email', 'password'); try &#123; // attempt to verify the credentials and create a token for the user if (! $token = JWTAuth::attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'invalid_credentials'], 401); &#125; &#125; catch (JWTException $e) &#123; // something went wrong whilst attempting to encode the token return response()-&gt;json(['error' =&gt; 'could_not_create_token'], 500); &#125; // all good so return the token return response()-&gt;json(compact('token')); &#125;&#125; 如果验证的密码字段不是 ‘password’，在要验证表的 model 中加入以下函数123public function getAuthPassword() &#123; return $this-&gt;user_password; //user_password为字段名&#125; 如果验证的用户字段字段不是 ‘email’ 是 ‘name’，在 ‘AuthController’ 中声明12345678//要这样验证$credentials = [ 'name' =&gt; $request-&gt;get('name'), 'password' =&gt; $request-&gt;get('password'), ];//加声明public $username = 'name'; （首选）方法2：通过用户对象实例创建token12$user = User::first(); //先获取用户$token = JWTAuth::fromUser($user);","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"JWTAuth","slug":"JWTAuth","permalink":"https://nancelglap.github.io/tags/JWTAuth/"},{"name":"dingo","slug":"dingo","permalink":"https://nancelglap.github.io/tags/dingo/"},{"name":"api","slug":"api","permalink":"https://nancelglap.github.io/tags/api/"}]},{"title":"数据的增删改","slug":"数据的增删改","date":"2017-05-02T08:20:01.000Z","updated":"2017-06-19T11:02:34.000Z","comments":true,"path":"2017/05/02/数据的增删改/","link":"","permalink":"https://nancelglap.github.io/2017/05/02/数据的增删改/","excerpt":"Controller中 store, destory, update方法","text":"Controller中 store, destory, update方法 1、增–store这里省去验证和文件上传步骤，详见laravel文件上传12345678910use App\\modelName;public function store(newRequest $request)&#123; $content = $request-&gt;except('_token', 'fileName'); //不包括token和文件上传 $content['filename'] = 'URL' . 'newFilename' . $file-&gt;getClientOriginalExtension(); modelName::create($content); redirect('/path');&#125; 2、删–destory1234567891011121314151617use App\\modelName;use File;public function destory($id)&#123; //先通过用户验证，进入相应用户的删除操作界面 $this -&gt; middleware('auth'); $content = modelName::find($id); //要删除的文件，引入File Facade File::delete('/path/fileName'); //删除数据库数据 $content -&gt; delete(); redirect('/path');&#125; 3、改–update改有两种方法可用，一种为直接新内容覆盖旧内容，另一种为逐条信息更新再update 第一种：覆盖 先不取出上传文件，后面处理后再加入数组，以下省略文件验证代码，详见larval文件上传12345678910111213use App\\modelName;use File;public function update(newRquest $request, $id)&#123; $new_data = $request-&gt;except('_token', 'filename'); $file = $request -&gt; file('filename'); $file -&gt; move('/path', 'fileNewName.extension'); File::delete('/path/fileName'); $raw_data = modelName::findOrFail($id); $raw_data -&gt; update($new_data);&#125; 第二种：逐条更新 缺点：要先在Controller中写好包含每列名称的关联数组12345678910111213141516171819202122use App\\modelName;protected $column_names = [ 'column_name1' =&gt; '', 'column_name2' =&gt; '', 'column_name3' =&gt; '', 'column_name4' =&gt; '',];public function update(newRequest $request, $id)&#123; $raw_data = modelName::findOrFail($id); //取出键名 foreach(array_keys(array_except($this-&gt;column_names, ['column_namex'])) as $key) &#123; $raw_data-&gt;$key = $request-&gt;get($key); &#125; $raw_data -&gt; save(); redirect('/path');&#125;","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"Controller","slug":"Controller","permalink":"https://nancelglap.github.io/tags/Controller/"}]},{"title":"Eloquent 关系","slug":"Eloquent-关系","date":"2017-05-02T01:28:10.000Z","updated":"2017-07-05T13:14:43.000Z","comments":true,"path":"2017/05/02/Eloquent-关系/","link":"","permalink":"https://nancelglap.github.io/2017/05/02/Eloquent-关系/","excerpt":"Eloquent 一对一等关系","text":"Eloquent 一对一等关系 1、设置外键（默认名称为user_id）1$table -&gt; integer('user_id') -&gt; default(1); //创建后第二个表中的所有数据都属于user表中id为1的用户 在链关系中如果最后一项为函数的话可以不用加( ) 2、创建关系 一对一关系 如果一个User模型与另一个model模型对应，定义一个method方法在User模型中，method方法调用Eloquent模型基类上hasOne方法并返回结果1234567891011&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function method() &#123; return $this-&gt;hasOne('App\\model'); &#125;&#125; hasOne方法的第一个参数为关联模型的名称。通过动态属性访问关联方法：12$new = User::find(1)-&gt;method; //返回结果集，可以进一步调用属性$new = User::find(1)-&gt;method-&gt;name; //返回在models表中user_id为1的信息的名字 hasOne方法默认关联外键为user_id，如果想让model的其他作为外键，传入第二个参数：1return $this -&gt; hasOne('App\\model', 'foreign_key'); hasOne方法默认通过id值去models表中查询user_id与之匹配的记录，如果想换主键匹配，传递第三个参数给hasOne:1return $this-&gt;hasOne('App\\model', 'foreign_key', 'local_key'); 定义相对的关联也可以在model模型中定义关系关联User，使用belongsTo方法定义；1234567891011&lt;?php namespace App; use Illuminat\\Database\\Eloquent\\Model; class model extends Model&#123; public function user() &#123; return $this-&gt;belongsTo('App\\User'); &#125; &#125; 如果model模型上的外键不是user_id，父模型不使用id作为主键：1234public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key', 'other_primarykey');&#125; 用法1$new = App\\model::find(1)-&gt;user(); //返回user表中id为1的信息 一对多关系 123456789101112&lt;?php namespace App; use Illuminate\\Database\\Eloquent\\Model; //Posts表有id作为主键 class Post extends Model&#123; public function comments() &#123; return $this -&gt; hasMany('App\\Comment'); &#125; &#125; Eloquent自动判断Comment模型的外键，默认某列中名称有_id后缀为外键访问关联方法（用法）：123456use App\\Post;$comments = App\\Post::find(1)-&gt;comments; //先用find找到一个用户，再调用函数foreach($comments as $comment)&#123; //&#125; 增加约束条件1$comments = App\\Post::find(1)-&gt;comments()-&gt;where()-&gt;first; 通过第二个参数，第三个参数自定义外键和主键1return $this-&gt;hasMany('App\\Comment', 'foreign_key', 'local_key'); 更多详见 laravelacademy.org/post/6996.html 只获取指定的字段 1return $this-&gt;belongsToMany(Permission::class)-&gt;select(array('name', 'description'));","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"Eloquent","slug":"Eloquent","permalink":"https://nancelglap.github.io/tags/Eloquent/"}]},{"title":"Laravel 文件上传处理","slug":"laravel文件上传","date":"2017-04-30T13:21:06.000Z","updated":"2017-06-19T11:03:41.000Z","comments":true,"path":"2017/04/30/laravel文件上传/","link":"","permalink":"https://nancelglap.github.io/2017/04/30/laravel文件上传/","excerpt":"Laravel文件上传操作","text":"Laravel文件上传操作 1.在blade文件中的表格指定文件上传的name1234&lt;form method=\"POST\" action=\"url\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123;csrf_token()&#125;&#125;\"&gt;&lt;input type=\"file\" name=\"newfile\"&gt;&lt;input type=\"submit\" name=\"sub\"&gt; 2.改配置文件修改config/filesystems.php文件，加入以下代码1234567'uploads' =&gt; [ 'driver' =&gt; 'local', //文件上传到storage/app/uploads目录 'root' =&gt; storage_path('app/uploads'), //如果文件上传到public/uploads目录 则上一行代码换成下面一行 //'root' =&gt; public_path('uploads'),] 3.在Controller中获取文件信息并上传getClientOriginalName方法获取文件原名getRealPath( )方法获取缓存在tmp文件夹下的文件绝对路径getClientOriginalExtension( )方法获取上传文件的后缀getMimeType( )方法返回类似image/jpeg1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Storage;use App\\Http\\Requests;class FileController extends Controller&#123; // 文件上传方法 public function upload(Request $request) &#123; if ($request-&gt;isMethod('post')) &#123; $file = $request-&gt;file('picture'); // 验证文件是否上传成功并处理上传 if ($file-&gt;isValid()) &#123; /*****获取文件相关信息*****/ $originalName = $file-&gt;getClientOriginalName(); // 文件原名 $ext = $file-&gt;getClientOriginalExtension(); // 扩展名 $realPath = $file-&gt;getRealPath(); //临时文件的绝对路径 $type = $file-&gt;getClientMimeType(); // image/jpeg /**********************/ /*****上传文件*****/ $filename = date('Y-m-d-H-i-s') . '-' . uniqid() . '.' . $ext; // 使用新建的uploads本地存储空间（目录） $bool = Storage::disk('uploads')-&gt;put($filename, file_get_contents($realPath)); /****************/ var_dump($bool); &#125; &#125; return view('upload'); &#125;&#125; 4.注意(CSRF报错) laravel默认开启CSRF验证，不是get请求的话需要验证CSRF 解决办法1：加隐藏表单如果表单中加了以下1&lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123;csrf_token()&#125;&#125;\"&gt; 仍然报以下错误，用解决办法21TokenMismatchException in VerifyCsrfToken.php line 68: 解决办法2：禁用CSRF修改文件：app\\Http\\Kernel.php，注释掉以下代码1'App\\Http\\Middleware\\VerifyCsrfToken' 可以直接使用 12$file = $request-&gt;file('filename');$file -&gt; move(public_path(),'/path', 'filename'); //移动到public/path下 验证上传图片类型并上传12345678910111213public function update(Request $request, $id)&#123; $content = $request-&gt;except('_token', 'filename'); if(!is_null($request-&gt;file('filename')))&#123; $this-&gt;validate($request, [ 'filename' =&gt; 'mimes:jpeg,png,gif' //filename为表单中file的name值 ]); $file = $request-&gt;file('filename'); //上传到指定文件夹 $file-&gt;move(public_path().'/path', 'newFileName'); //文件名最后补上后缀 &#125;&#125; validate方法接收一个HTTP请求输入数据和验证规则，如果验证规则通过，代码将会继续往下执行；然而，如果验证失败，将会抛出一个异常，相应的错误响应也会自动发送给用户。","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"}]},{"title":"Route 相关","slug":"Route相关","date":"2017-04-30T12:21:49.000Z","updated":"2017-06-19T11:05:05.000Z","comments":true,"path":"2017/04/30/Route相关/","link":"","permalink":"https://nancelglap.github.io/2017/04/30/Route相关/","excerpt":"Route相关知识","text":"Route相关知识 项目中一般不用Route::resource( )Http方法patch对应Controller的update函数Http方法delete对应Controller的destory函数Http方法post对应Controller的store函数Http方法get且路径为/path/create对应Controller的create函数特殊:get路径为/path/{参数}/edit对应Controller的edit函数 部分资源路由（Resource）12Route::resource('new', 'newController', ['only'=&gt;['index', 'show']]); //只处理index和show方法Route::resource('new', 'newController', ['except'=&gt;['create', 'store']]); //处理除了create和store的方法 重定向到Controller Action12//第二个参数为可选参数return redirect() -&gt; action('MyController@index', ['id' =&gt; 1]);","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"Route","slug":"Route","permalink":"https://nancelglap.github.io/tags/Route/"}]},{"title":"Blade 相关","slug":"Blade-Warning","date":"2017-04-29T13:06:20.000Z","updated":"2017-06-19T11:02:48.000Z","comments":true,"path":"2017/04/29/Blade-Warning/","link":"","permalink":"https://nancelglap.github.io/2017/04/29/Blade-Warning/","excerpt":"","text":"一、blade实现编辑页面自动填充表单1. 在Controller中1$content = model名::findOrFail($id); 2. 在视图文件中使用Form-Model-Binding1&#123;!! Form::model($content, [&apos;method&apos;=&gt;&apos;PATCH&apos;, &apos;url&apos;=&gt;&apos;/path/&apos;.$content-&gt;id]) !!&#125; 二、Blade模板中的注意事项 如果从Controller传过来的数组为一维关联数组，可以直接用数组中的键作为变量 重用的代码放到一个文件里，在需要用的视图文件用@include(&#39;view&#39;s name&#39;) 三、视图绑定变量1、一般在被其他视图文件包含的视图文件使用，不用额外再写代码2、创建一个类文件，比如在App\\ClassName3、在视图文件中用 @inject(&#39;var&#39;, &#39;ClassFile_Path&#39;) 绑定变量123@inject('var', 'App\\ClassName')$var-&gt;method(); //调用ClassName类中的方法","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"blade","slug":"blade","permalink":"https://nancelglap.github.io/tags/blade/"}]},{"title":"Laravel 函数","slug":"My-New-Post","date":"2017-04-29T04:28:00.000Z","updated":"2017-06-19T11:04:34.000Z","comments":true,"path":"2017/04/29/My-New-Post/","link":"","permalink":"https://nancelglap.github.io/2017/04/29/My-New-Post/","excerpt":"有关laravel的函数","text":"有关laravel的函数 old( )函数old函数获取一次性从Session获取的值，如果有第二个参数，则代表函数当第一个参数不存在时取第二个参数 当表单被填充但是验证失败需要返回原始输入数据 12345//$fields为默认值的关联数组$data = [];foreach ($this-&gt;fields as $field =&gt; $default)&#123; $data[$field] = old($field, $default);&#125; array_except( )函数array_except方法从数组中移除给定键值对，第二个参数为[&#39;键名&#39;]1$array = array_except($array, ['price']); //移除array数组以`price`为键的键值对 array_keys( )函数array_keys函数返回包含数组中所有键名的一个新数组12$a = $array(\"name\"=&gt;\"lee\", \"sex\"=&gt;\"male\");$b = array_keys($a); //b为array([0]=&gt;name, [1]=&gt;sex) withSuccess( )函数withSuccess函数参数为一个字符串语句，在重定向redirect( )后使用，在相应的视图文件中可用Session类获取12345//在控制器中 redirect('/path') -&gt; withSuccess('Succeed.');//在视图文件中 Session::has('success'); //判断是否存在 Session::get('success'); //获取控制器中withSuccess()中的字符串 strstr( )函数strstr函数查找第二个参数在第一个参数中第一次出现位置，并返回字符串剩余的部分12echo strstr('I love China.', 'love');//输出'love China' strtotime( )函数strtotime返回Unix时间戳1strtotime(date('Y-m-d H:i:s', time()));","categories":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nancelglap.github.io/tags/laravel/"},{"name":"blade","slug":"blade","permalink":"https://nancelglap.github.io/tags/blade/"}]}]}