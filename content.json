{"meta":{"title":"Nancelglap的博客","subtitle":"不想正经","description":"广工无名小卒","author":"Nancelglap","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"用户认证","slug":"用户认证","date":"2017-05-10T14:12:12.000Z","updated":"2017-05-10T14:37:06.000Z","comments":true,"path":"2017/05/10/用户认证/","link":"","permalink":"http://yoursite.com/2017/05/10/用户认证/","excerpt":"","text":"一、auth.php文件配置(修改auth验证的表) 在guards数组中的每一项都是一个角色，默认的有web和api两种，这就表示了当前有这两种角色会使用到认证系统。driver就是表示这个认证要怎么去保存用户状态，一般是保存在session中，provider就是告诉Laravel你的用户信息保存在哪一张表里面，driver就是告诉了要使用那种方式来操作数据库。 二、具体运用 方法一：在Controller中增加middleware键值对当路由中使用了保护路由：&#39;middleware&#39; =&gt; &#39;auth&#39;，此路由需先经过路由的路径名为’/login’执行后才跳转到此路由执行可以对路由组使用此中间件，以下组内所有路由的访问都需先经过路由路径为’/login’的认证路由中的路径必须是根目录下的’/login’1234//如果路径前面再加任何的前缀就会出错'/admin/path'Route::get('/login', function() &#123; return view('auth.login'); &#125;) 1234567Route::group(['namespace'=&gt;'Admin', 'middleware'=&gt;'auth'], function()&#123; Route::get('admin/path1', 'UploadController@method1'); Route::get('admin/path2', 'UploadController@method2'); Route::get('admin/path3', 'UploadController@method3'); Route::get('admin/path4', 'UploadController@method4');&#125; 方法二：在控制器中增加构造方法__construct1234public function __construct()&#123; $this-&gt;middleware('auth');&#125;","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"middleware","slug":"middleware","permalink":"http://yoursite.com/tags/middleware/"},{"name":"auth","slug":"auth","permalink":"http://yoursite.com/tags/auth/"}]},{"title":"JWT + dingo","slug":"JWT-dingo","date":"2017-05-10T12:01:07.000Z","updated":"2017-05-10T14:11:06.000Z","comments":true,"path":"2017/05/10/JWT-dingo/","link":"","permalink":"http://yoursite.com/2017/05/10/JWT-dingo/","excerpt":"laravel 中JWT(Json Web Token)和dingo的使用","text":"laravel 中JWT(Json Web Token)和dingo的使用 dingo dingo的作用给前端提供数据接口，前后端分离，返回JSON数据 一、安装 安装方法 1修改composer.json文件，执行composer update把最后一个版本的包加入项目中123\"required\": &#123; \"dingo/api\": \"1.0.*@dev\"&#125; 安装方法 2在命令行执行composer require命令1composer require dingo/api:1.0.x@dev 二、配置 1、打开config/app.php，注册service provider123'provider' =&gt; [ Dingo\\Api\\Provider\\LaravelServiceProvider::class] 2、如果想在配置文件中改变配置，使用下面Artisan命令发布配置文件1php artisan vendor:publish --provider=\"Dingo\\Api\\Provider\\LaravelServiceProvider\" 3、在.env中添加基础基础配置1234567API_STANDARDS_TREE = vndAPI_PREFIX = apiAPI_VERSION = v1API_DEBUG = true 三、使用 1、在routes\\api.php中123456789101112$api = app('Dingo\\Api\\Routing\\Router');$api -&gt; group(['namespace' =&gt; 'App\\Api\\Controllers'], function ($api) &#123; $api -&gt; get('login', 'Controllers@method'); ...; //只有在编辑信息，删除信息，创建信息的时候需要通过JWT验证客户端是否为登录的用户 $api -&gt; group(['middleware' =&gt; 'jwt.api.auth'], function ($api) &#123; $api -&gt; patch('/path/&#123;id&#125;', 'Controllers@update'); $api -&gt; post('/path/delete', 'Controllers@destory'); $api -&gt; post('/path/create', 'Controllers@store'); &#125;) &#125;) 2、创建Controller在\\App\\Api下创建Controller和Transformers目录在Controllers下创建BaseController.php作为被继承的基础模块1234567891011121314151617181920&lt;?php namespace App\\Api\\Controllers; use App\\Http\\Controllers\\Controller; use Dingo\\Api\\Routing\\Helpers; class BaseController extends Controller &#123; use Helpers; /**** * BaseController constructor. */ public function __construct() &#123; &#125; &#125; JWTAuth JWTAuth的作用在用户登录的时候根据要求的登录信息，token签发时间(iat)，token过期时间(exp)等进行base64编码得到的字符串叫做Payload（载荷）。之后用户的每次提交给服务器的行为都会带上token证明客户端用户身份 一、安装 安装方法 1使用Composer安装JWT扩展包：composer require tymon/jwt-auth 0.5.* 安装方法 2修改composer.json文件，执行composer update把最后一个版本的包加入项目中123\"required\": &#123; \"tymon/jwt-auth\":\"0.5.*\"&#125; 二、配置 1、在config/app.php中注册相应的Service Provider 123'providers'=&gt;[ Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class, ] 2、注册jwt Facades1234'aliases'=&gt;[ 'JWTAuth'=&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class, 'JWTFactory'=&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class, ] 3、更新配置文件php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider&quot; 4、生成jwt.php文件中数组的secret键成对应的值php artisan jwt:generate 关联dingo和JWT 修改config/api.php的auth12345678'auth' =&gt; [ 'basic' =&gt; function($app)&#123; return new Dingo\\Api\\Auth\\Provider\\Basic($app['auth']); &#125;, 'jwt' =&gt; function($app)&#123; return new Dingo\\Api\\Auth\\Provider\\JWT($app['Tymon\\JWTAuth\\JWTAuth']); &#125;], 具体运用 1、添加中间件身份验证添加一个Middleware：GetUserFromTokenphp artisan make:middleware GetUserFromToken 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\\Http\\Middleware;use Closure;use JWTAuth;use Tymon\\JWTAuth\\Exceptions\\JWTException;use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException;use Tymon\\JWTAuth\\Exceptions\\TokenInvalidException;class GetUserFromToken&#123; public function handle($request, Closure $next) &#123; $auth = JWTAuth::parseToken(); if (! $token = $auth-&gt;setRequest($request)-&gt;getToken()) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_not_provided', 'data' =&gt; '', ]); &#125; try &#123; $user = $auth-&gt;authenticate($token); &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_expired', 'data' =&gt; '', ]); &#125; catch (JWTException $e) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'token_invalid', 'data' =&gt; '', ]); &#125; if (! $user) &#123; return response()-&gt;json([ 'code' =&gt; '', 'message' =&gt; 'user_not_found', 'data' =&gt; '', ]); &#125; //$this-&gt;events-&gt;fire('tymon.jwt.valid', $user); return $next($request); &#125;&#125; 2、在/app/hTTP/Kernel.php中routeMiddleware新增如下内容1234protected $routeMiddleware = [ ... 'jwt.api.auth' =&gt; \\App\\Http\\Middleware\\GetUserFromToken::class, //新增注册的中间件]; 3、验证表格更改如果要修改验证的用户表名，修改config/jwt.php&#39;user&#39; =&gt; &#39;App\\newName&#39;, 4、认证模块添加关注一下logout和register在AuthController中添加相应模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php namespace App\\Api\\Controllers; use App\\Client; use Illuminate\\Http\\Request; use JWTAuth; use Tymon\\JWTAuth\\Exceptions\\JWTException; use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException; use Tymon\\JWTAuth\\Exceptions\\TokenInvalidException; class AuthController extends BaseController &#123; /** * The authentication guard that should be used. * * @var string */ public function __construct() &#123; parent::__construct(); &#125; /** * @param Request $request * @return \\Illuminate\\Http\\JsonResponse */ public function authenticate(Request $request) &#123; $payload = [ 'user_email' =&gt; $request-&gt;get('email'), 'password' =&gt; $request-&gt;get('password') ]; try &#123; if (!$token = JWTAuth::attempt($payload)) &#123; return response()-&gt;json(['error' =&gt; 'token_not_provided'], 401); &#125; &#125; catch (JWTException $e) &#123; return response()-&gt;json(['error' =&gt; '不能创建token'], 500); &#125; return response()-&gt;json(compact('token')); &#125; public function logout() &#123; JWTAuth::refresh(); //刷新token，注意区别于middleware的auth $arr = array ('LOG OUT'=&gt;\"SUCCESSED\"); return response()-&gt;json(compact('arr')); &#125; /** * @param Request $request */ public function register(Request $request) &#123; $newUser = [ 'user_email' =&gt; $request-&gt;get('email'), 'user_name' =&gt; $request-&gt;get('name'), 'password' =&gt; bcrypt($request-&gt;get('password')) ]; $user = Client::create($newUser); $token = JWTAuth::fromUser($user); return $token; &#125; /**** * 获取用户的信息 * @return \\Illuminate\\Http\\JsonResponse */ public function AuthenticatedUser() &#123; try &#123; if (!$user = JWTAuth::parseToken()-&gt;authenticate()) &#123; return response()-&gt;json(['user_not_found'], 404); &#125; &#125; catch (TokenExpiredException $e) &#123; return response()-&gt;json(['token_expired'], $e-&gt;getStatusCode()); &#125; catch (TokenInvalidException $e) &#123; return response()-&gt;json(['token_invalid'], $e-&gt;getStatusCode()); &#125; catch (JWTException $e) &#123; return response()-&gt;json(['token_absent'], $e-&gt;getStatusCode()); &#125; // the token is valid and we have found the user via the sub claim return response()-&gt;json(compact('user')); &#125; &#125; 5、编辑Transformers目录(可选)在Transformers目录下添加TestsTransformer.php文件代码如下：123456789101112131415161718192021222324&lt;?php namespace App\\Api\\Transformers; /**该类为dingo api封装好**/ use League\\Fractal\\TransformerAbstract; class TestsTransformer extends TransformerAbstract &#123; /*** * 分开为了解耦 * 数据字段选择 * @param $lesson * @return array */ public function transform($lesson) &#123; /******隐藏数据库字段*****/ return [ 'username' =&gt; $lesson['user_name'], 'email' =&gt; $lesson['user_email'], ]; &#125; &#125; 6、在路由中指定使用jwt.api.auth[&#39;middleware&#39; =&gt; &#39;jwt.api.auth&#39;]","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"},{"name":"dingo","slug":"dingo","permalink":"http://yoursite.com/tags/dingo/"}]},{"title":"Shell脚本相关","slug":"Shell脚本相关","date":"2017-05-10T08:39:54.000Z","updated":"2017-05-10T08:47:53.000Z","comments":true,"path":"2017/05/10/Shell脚本相关/","link":"","permalink":"http://yoursite.com/2017/05/10/Shell脚本相关/","excerpt":"本文内容为bash操作相关","text":"本文内容为bash操作相关1、要输出感叹号的时候不要放在双引号内，如果要的话要加“\\”反斜杠","categories":[{"name":"note of \"Linux shell 脚本攻略\"","slug":"note-of-Linux-shell-脚本攻略","permalink":"http://yoursite.com/categories/note-of-Linux-shell-脚本攻略/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"}]},{"title":"token的创建","slug":"创建token","date":"2017-05-06T13:49:41.000Z","updated":"2017-05-10T13:23:45.000Z","comments":true,"path":"2017/05/06/创建token/","link":"","permalink":"http://yoursite.com/2017/05/06/创建token/","excerpt":"用户登录的时候服务器返回相应用户的token给客户端，接下来用户的每次请求都会发送token给服务器端验证身份","text":"用户登录的时候服务器返回相应用户的token给客户端，接下来用户的每次请求都会发送token给服务器端验证身份 创建Token 方法1：用户登录的时候返回123456789101112131415161718192021222324use JWTAuth;use Tymon\\JWTAuth\\Exceptions\\JWTException;class AuthenticateController extends Controller&#123; public function authenticate(Request $request) &#123; // grab credentials from the request $credentials = $request-&gt;only('email', 'password'); try &#123; // attempt to verify the credentials and create a token for the user if (! $token = JWTAuth::attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'invalid_credentials'], 401); &#125; &#125; catch (JWTException $e) &#123; // something went wrong whilst attempting to encode the token return response()-&gt;json(['error' =&gt; 'could_not_create_token'], 500); &#125; // all good so return the token return response()-&gt;json(compact('token')); &#125;&#125; 方法2：通过用户对象实例创建token12$user = User::first(); //先获取用户$token = JWTAuth::fromUser($user);","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"dingo","slug":"dingo","permalink":"http://yoursite.com/tags/dingo/"},{"name":"JWTAuth","slug":"JWTAuth","permalink":"http://yoursite.com/tags/JWTAuth/"}]},{"title":"数据的增删改","slug":"数据的增删改","date":"2017-05-02T08:20:01.000Z","updated":"2017-05-02T09:10:42.000Z","comments":true,"path":"2017/05/02/数据的增删改/","link":"","permalink":"http://yoursite.com/2017/05/02/数据的增删改/","excerpt":"Controller中 store, destory, update方法","text":"Controller中 store, destory, update方法 1、增–store这里省去验证和文件上传步骤，详见laravel文件上传12345678910use App\\modelName;public function store(newRequest $request)&#123; $content = $request-&gt;except('_token', 'fileName'); //不包括token和文件上传 $content['filename'] = 'URL' . 'newFilename' . $file-&gt;getClientOriginalExtension(); modelName::create($content); redirect('/path');&#125; 2、删–destory1234567891011121314151617use App\\modelName;use File;public function destory($id)&#123; //先通过用户验证，进入相应用户的删除操作界面 $this -&gt; middleware('auth'); $content = modelName::find($id); //要删除的文件，引入File Facade File::delete('/path/fileName'); //删除数据库数据 $content -&gt; delete(); redirect('/path');&#125; 3、改–update改有两种方法可用，一种为直接新内容覆盖旧内容，另一种为逐条信息更新再update 第一种：覆盖 先不取出上传文件，后面处理后再加入数组，以下省略文件验证代码，详见larval文件上传12345678910111213use App\\modelName;use File;public function update(newRquest $request, $id)&#123; $new_data = $request-&gt;except('_token', 'filename'); $file = $request -&gt; file('filename'); $file -&gt; move('/path', 'fileNewName.extension'); File::delete('/path/fileName'); $raw_data = modelName::findOrFail($id); $raw_data -&gt; update($new_data);&#125; 第二种：逐条更新 缺点：要先在Controller中写好包含每列名称的关联数组12345678910111213141516171819202122use App\\modelName;protected $column_names = [ 'column_name1' =&gt; '', 'column_name2' =&gt; '', 'column_name3' =&gt; '', 'column_name4' =&gt; '',];public function update(newRequest $request, $id)&#123; $raw_data = modelName::findOrFail($id); //取出键名 foreach(array_keys(array_except($this-&gt;column_names, ['column_namex'])) as $key) &#123; $raw_data-&gt;$key = $request-&gt;get($key); &#125; $raw_data -&gt; save(); redirect('/path');&#125;","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"Controller","slug":"Controller","permalink":"http://yoursite.com/tags/Controller/"}]},{"title":"Eloquent 关系","slug":"Eloquent-关系","date":"2017-05-02T01:28:10.000Z","updated":"2017-05-02T07:33:07.000Z","comments":true,"path":"2017/05/02/Eloquent-关系/","link":"","permalink":"http://yoursite.com/2017/05/02/Eloquent-关系/","excerpt":"Eloquent 一对一等关系","text":"Eloquent 一对一等关系 1、设置外键（默认名称为user_id）1$table -&gt; integer(&apos;user_id&apos;) -&gt; default(1); //创建后第二个表中的所有数据都属于user表中id为1的用户 在链关系中如果最后一项为函数的话可以不用加( ) 2、创建关系 一对一关系 如果一个User模型与另一个model模型对应，定义一个method方法在User模型中，method方法调用Eloquent模型基类上hasOne方法并返回结果1234567891011&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function method() &#123; return $this-&gt;hasOne('App\\model'); &#125;&#125; hasOne方法的第一个参数为关联模型的名称。通过动态属性访问关联方法：12$new = User::find(1)-&gt;method; //返回结果集，可以进一步调用属性$new = User::find(1)-&gt;method-&gt;name; //返回在models表中user_id为1的信息的名字 hasOne方法默认关联外键为user_id，如果想让model的其他作为外键，传入第二个参数：1return $this -&gt; hasOne('App\\model', 'foreign_key'); hasOne方法默认通过id值去models表中查询user_id与之匹配的记录，如果想换主键匹配，传递第三个参数给hasOne:1return $this-&gt;hasOne('App\\model', 'foreign_key', 'local_key'); 定义相对的关联也可以在model模型中定义关系关联User，使用belongsTo方法定义；1234567891011&lt;?php namespace App; use Illuminat\\Database\\Eloquent\\Model; class model extends Model&#123; public function user() &#123; return $this-&gt;belongsTo('App\\User'); &#125; &#125; 如果model模型上的外键不是user_id，父模型不使用id作为主键：1234public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key', 'other_primarykey');&#125; 用法1$new = App\\model::find(1)-&gt;user(); //返回user表中id为1的信息 一对多关系 123456789101112&lt;?php namespace App; use Illuminate\\Database\\Eloquent\\Model; //Posts表有id作为主键 class Post extends Model&#123; public function comments() &#123; return $this -&gt; hasMany('App\\Comment'); &#125; &#125; Eloquent自动判断Comment模型的外键，默认某列中名称有_id后缀为外键访问关联方法（用法）：123456use App\\Post;$comments = App\\Post::find(1)-&gt;comments; //先用find找到一个用户，再调用函数foreach($comments as $comment)&#123; //&#125; 增加约束条件1$comments = App\\Post::find(1)-&gt;comments()-&gt;where()-&gt;first; 通过第二个参数，第三个参数自定义外键和主键1return $this-&gt;hasMany('App\\Comment', 'foreign_key', 'local_key'); 更多详见 laravelacademy.org/post/6996.html","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"Eloquent","slug":"Eloquent","permalink":"http://yoursite.com/tags/Eloquent/"}]},{"title":"Laravel 文件上传处理","slug":"laravel文件上传","date":"2017-04-30T13:21:06.000Z","updated":"2017-05-08T14:23:36.000Z","comments":true,"path":"2017/04/30/laravel文件上传/","link":"","permalink":"http://yoursite.com/2017/04/30/laravel文件上传/","excerpt":"Laravel文件上传操作","text":"Laravel文件上传操作 1.在blade文件中的表格指定文件上传的name1234&lt;form method=\"POST\" action=\"url\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123;csrf_token()&#125;&#125;\"&gt;&lt;input type=\"file\" name=\"newfile\"&gt;&lt;input type=\"submit\" name=\"sub\"&gt; 2.改配置文件修改config/filesystems.php文件，加入以下代码1234567&apos;uploads&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;local&apos;, //文件上传到storage/app/uploads目录 &apos;root&apos; =&gt; storage_path(&apos;app/uploads&apos;), //如果文件上传到public/uploads目录 则上一行代码换成下面一行 //&apos;root&apos; =&gt; public_path(&apos;uploads&apos;),] 3.在Controller中获取文件信息并上传getClientOriginalName方法获取文件原名getRealPath( )方法获取缓存在tmp文件夹下的文件绝对路径getClientOriginalExtension( )方法获取上传文件的后缀getMimeType( )方法返回类似image/jpeg1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Storage;use App\\Http\\Requests;class FileController extends Controller&#123; // 文件上传方法 public function upload(Request $request) &#123; if ($request-&gt;isMethod('post')) &#123; $file = $request-&gt;file('picture'); // 验证文件是否上传成功并处理上传 if ($file-&gt;isValid()) &#123; /*****获取文件相关信息*****/ $originalName = $file-&gt;getClientOriginalName(); // 文件原名 $ext = $file-&gt;getClientOriginalExtension(); // 扩展名 $realPath = $file-&gt;getRealPath(); //临时文件的绝对路径 $type = $file-&gt;getClientMimeType(); // image/jpeg /**********************/ /*****上传文件*****/ $filename = date('Y-m-d-H-i-s') . '-' . uniqid() . '.' . $ext; // 使用新建的uploads本地存储空间（目录） $bool = Storage::disk('uploads')-&gt;put($filename, file_get_contents($realPath)); /****************/ var_dump($bool); &#125; &#125; return view('upload'); &#125;&#125; 4.注意(CSRF报错) laravel默认开启CSRF验证，不是get请求的话需要验证CSRF 解决办法1：加隐藏表单如果表单中加了以下1&lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123;csrf_token()&#125;&#125;\"&gt; 仍然报以下错误，用解决办法21TokenMismatchException in VerifyCsrfToken.php line 68: 解决办法2：禁用CSRF修改文件：app\\Http\\Kernel.php，注释掉以下代码1&apos;App\\Http\\Middleware\\VerifyCsrfToken&apos; 可以直接使用 12$file = $request-&gt;file('filename');$file -&gt; move(public_path(),'/path', 'filename'); //移动到public/path下 验证上传图片类型并上传12345678910111213public function update(Request $request, $id)&#123; $content = $request-&gt;except('_token', 'filename'); if(!is_null($request-&gt;file('filename')))&#123; $this-&gt;validate($request, [ 'filename' =&gt; 'mimes:jpeg,png,gif' //filename为表单中file的name值 ]); $file = $request-&gt;file('filename'); //上传到指定文件夹 $file-&gt;move(public_path().'/path', 'newFileName'); //文件名最后补上后缀 &#125;&#125; validate方法接收一个HTTP请求输入数据和验证规则，如果验证规则通过，代码将会继续往下执行；然而，如果验证失败，将会抛出一个异常，相应的错误响应也会自动发送给用户。","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"}]},{"title":"Route 相关","slug":"Route相关","date":"2017-04-30T12:21:49.000Z","updated":"2017-05-03T01:37:31.000Z","comments":true,"path":"2017/04/30/Route相关/","link":"","permalink":"http://yoursite.com/2017/04/30/Route相关/","excerpt":"Route相关知识","text":"Route相关知识 项目中一般不用Route::resource( )Http方法patch对应Controller的update函数Http方法delete对应Controller的destory函数Http方法post对应Controller的store函数Http方法get且路径为/path/create对应Controller的create函数特殊:get路径为/path/{参数}/edit对应Controller的edit函数 部分资源路由（Resource）12Route::resource('new', 'newController', ['only'=&gt;['index', 'show']]); //只处理index和show方法Route::resource('new', 'newController', ['except'=&gt;['create', 'store']]); //处理除了create和store的方法 重定向到Controller Action12//第二个参数为可选参数return redirect() -&gt; action(&apos;MyController@index&apos;, [&apos;id&apos; =&gt; 1]);","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"Route","slug":"Route","permalink":"http://yoursite.com/tags/Route/"}]},{"title":"Blade 相关","slug":"Blade-Warning","date":"2017-04-29T13:06:20.000Z","updated":"2017-05-01T02:19:00.000Z","comments":true,"path":"2017/04/29/Blade-Warning/","link":"","permalink":"http://yoursite.com/2017/04/29/Blade-Warning/","excerpt":"","text":"一、blade实现编辑页面自动填充表单1. 在Controller中1$content = model名::findOrFail($id); 2. 在视图文件中使用Form-Model-Binding1&#123;!! Form::model($content, [&apos;method&apos;=&gt;&apos;PATCH&apos;, &apos;url&apos;=&gt;&apos;/path/&apos;.$content-&gt;id]) !!&#125; 二、Blade模板中的注意事项 如果从Controller传过来的数组为一维关联数组，可以直接用数组中的键作为变量 重用的代码放到一个文件里，在需要用的视图文件用@include(&#39;view&#39;s name&#39;)","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"blade","slug":"blade","permalink":"http://yoursite.com/tags/blade/"}]},{"title":"Laravel 函数","slug":"My-New-Post","date":"2017-04-29T04:28:00.000Z","updated":"2017-05-02T08:12:32.000Z","comments":true,"path":"2017/04/29/My-New-Post/","link":"","permalink":"http://yoursite.com/2017/04/29/My-New-Post/","excerpt":"有关laravel的函数","text":"有关laravel的函数 old( )函数old函数获取一次性从Session获取的值，如果有第二个参数，则代表函数当第一个参数不存在时取第二个参数 当表单被填充但是验证失败需要返回原始输入数据 12345//$fields为默认值的关联数组$data = [];foreach ($this-&gt;fields as $field =&gt; $default)&#123; $data[$field] = old($field, $default);&#125; array_except( )函数array_except方法从数组中移除给定键值对，第二个参数为[&#39;键名&#39;]1$array = array_except($array, ['price']); //移除array数组以`price`为键的键值对 array_keys( )函数array_keys函数返回包含数组中所有键名的一个新数组12$a = $array(\"name\"=&gt;\"lee\", \"sex\"=&gt;\"male\");$b = array_keys($a); //b为array([0]=&gt;name, [1]=&gt;sex) withSuccess( )函数withSuccess函数参数为一个字符串语句，在重定向redirect( )后使用，在相应的视图文件中可用Session类获取12345//在控制器中 redirect('/path') -&gt; withSuccess('Succeed.');//在视图文件中 Session::has('success'); //判断是否存在 Session::get('success'); //获取控制器中withSuccess()中的字符串 strstr( )函数strstr函数查找第二个参数在第一个参数中第一次出现位置，并返回字符串剩余的部分12echo strstr('I love China.', 'love');//输出'love China' strtotime( )函数strtotime返回Unix时间戳1strtotime(date('Y-m-d H:i:s', time()));","categories":[{"name":"note","slug":"note","permalink":"http://yoursite.com/categories/note/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"blade","slug":"blade","permalink":"http://yoursite.com/tags/blade/"}]}]}